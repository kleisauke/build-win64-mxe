This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Fri, 27 Dec 2019 18:00:00 +0100
Subject: [PATCH 1/2] Quote the ffi_closure_inner symbol

Fixes the llvm-mingw x86 build.

Similar to: https://bugzilla.mozilla.org/show_bug.cgi?id=1490568

diff --git a/src/x86/sysv.S b/src/x86/sysv.S
index 1111111..2222222 100644
--- a/src/x86/sysv.S
+++ b/src/x86/sysv.S
@@ -57,7 +57,7 @@
 /* Handle win32 fastcall name mangling.  */
 #ifdef X86_WIN32
 # define ffi_call_i386		@ffi_call_i386@8
-# define ffi_closure_inner	@ffi_closure_inner@8
+# define ffi_closure_inner	"@ffi_closure_inner@8"
 #else
 # define ffi_call_i386		C(ffi_call_i386)
 # define ffi_closure_inner	C(ffi_closure_inner)

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Fri, 14 Feb 2020 21:30:00 +0100
Subject: [PATCH 2/2] Fixes for the llvm-mingw ARM/ARM64 build


diff --git a/configure.host b/configure.host
index 1111111..2222222 100644
--- a/configure.host
+++ b/configure.host
@@ -8,7 +8,9 @@
 case "${host}" in
   aarch64*-*-cygwin* | aarch64*-*-mingw* | aarch64*-*-win* )
 	TARGET=ARM_WIN64; TARGETDIR=aarch64
-	MSVC=1
+	if test "${ax_cv_c_compiler_vendor}" = "microsoft"; then
+	  MSVC=1
+	fi
 	;;
 
   aarch64*-*-*)
@@ -30,7 +32,9 @@ case "${host}" in
 
   arm*-*-cygwin* | arm*-*-mingw* | arm*-*-win* )
 	TARGET=ARM_WIN32; TARGETDIR=arm
-	MSVC=1
+	if test "${ax_cv_c_compiler_vendor}" = "microsoft"; then
+	  MSVC=1
+	fi
 	;;
 
   arm*-*-*)
@@ -253,10 +257,18 @@ esac
 # ... but some of the cases above share configury.
 case "${TARGET}" in
   ARM_WIN32)
-	SOURCES="ffi.c sysv_msvc_arm32.S"
+	if test "$MSVC" = 1; then
+		SOURCES="ffi.c sysv_msvc_arm32.S"
+	else
+		SOURCES="ffi.c sysv.S"
+	fi
 	;;
   ARM_WIN64)
-	SOURCES="ffi.c win64_armasm.S"
+	if test "$MSVC" = 1; then
+		SOURCES="ffi.c win64_armasm.S"
+	else
+		SOURCES="ffi.c sysv.S"
+	fi
 	;;
   MIPS)
 	SOURCES="ffi.c o32.S n32.S"
diff --git a/src/aarch64/ffi.c b/src/aarch64/ffi.c
index 1111111..2222222 100644
--- a/src/aarch64/ffi.c
+++ b/src/aarch64/ffi.c
@@ -19,7 +19,7 @@ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#if defined(__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)
+#if defined(__aarch64__) || defined(__arm64__)|| defined (ARM_WIN64)
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
@@ -27,7 +27,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <ffi.h>
 #include <ffi_common.h>
 #include "internal.h"
-#ifdef _M_ARM64
+#ifdef ARM_WIN64
 #include <windows.h> /* FlushInstructionCache */
 #endif
 
@@ -78,7 +78,7 @@ ffi_clear_cache (void *start, void *end)
   sys_icache_invalidate (start, (char *)end - (char *)start);
 #elif defined (__GNUC__)
   __builtin___clear_cache (start, end);
-#elif defined (_M_ARM64)
+#elif defined (ARM_WIN64)
   FlushInstructionCache(GetCurrentProcess(), start, (char*)end - (char*)start);
 #else
 #error "Missing builtin to flush instruction cache"
@@ -665,7 +665,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,
 	    if (h)
 	      {
 		int elems = 4 - (h & 3);
-#ifdef _M_ARM64 /* for handling armasm calling convention */
+#ifdef ARM_WIN64 /* for handling armasm calling convention */
                 if (cif->is_variadic)
                   {
                     if (state.ngrn + elems <= N_X_ARG_REG)
@@ -690,7 +690,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,
 		  }
 		state.nsrn = N_V_ARG_REG;
 		dest = allocate_to_stack (&state, stack, ty->alignment, s);
-#ifdef _M_ARM64 /* for handling armasm calling convention */
+#ifdef ARM_WIN64 /* for handling armasm calling convention */
 	      }
 #endif /* for handling armasm calling convention */
 	      }
@@ -808,7 +808,7 @@ ffi_prep_closure_loc (ffi_closure *closure,
   ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);
 
   /* Also flush the cache for code mapping.  */
-#ifdef _M_ARM64
+#ifdef ARM_WIN64
   // Not using dlmalloc.c for Windows ARM64 builds
   // so calling ffi_data_to_code_pointer() isn't necessary
   unsigned char *tramp_code = tramp;
@@ -914,7 +914,7 @@ ffi_closure_SYSV_inner (ffi_cif *cif,
 	  if (h)
 	    {
 	      n = 4 - (h & 3);
-#ifdef _M_ARM64  /* for handling armasm calling convention */
+#ifdef ARM_WIN64  /* for handling armasm calling convention */
               if (cif->is_variadic)
                 {
                   if (state.ngrn + n <= N_X_ARG_REG)
@@ -954,7 +954,7 @@ ffi_closure_SYSV_inner (ffi_cif *cif,
                       avalue[i] = allocate_to_stack(&state, stack,
                                                    ty->alignment, s);
                     }
-#ifdef _M_ARM64  /* for handling armasm calling convention */
+#ifdef ARM_WIN64  /* for handling armasm calling convention */
                 }
 #endif  /* for handling armasm calling convention */
             }
@@ -1006,4 +1006,4 @@ ffi_closure_SYSV_inner (ffi_cif *cif,
   return flags;
 }
 
-#endif /* (__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)*/
+#endif /* defined(__aarch64__) || defined(__arm64__) || defined(ARM_WIN64)*/
diff --git a/src/aarch64/ffitarget.h b/src/aarch64/ffitarget.h
index 1111111..2222222 100644
--- a/src/aarch64/ffitarget.h
+++ b/src/aarch64/ffitarget.h
@@ -32,8 +32,11 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define FFI_SIZEOF_JAVA_RAW  4
 typedef unsigned long long ffi_arg;
 typedef signed long long ffi_sarg;
-#elif defined(_M_ARM64)
+#elif defined(ARM_WIN64)
 #define FFI_SIZEOF_ARG 8
+#ifdef __MINGW32__
+#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
+#endif
 typedef unsigned long long ffi_arg;
 typedef signed long long ffi_sarg;
 #else
@@ -69,7 +72,7 @@ typedef enum ffi_abi
 #define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE
 #endif
 
-#ifdef _M_ARM64
+#ifdef ARM_WIN64
 #define FFI_EXTRA_CIF_FIELDS unsigned is_variadic
 #endif
 
@@ -78,13 +81,13 @@ typedef enum ffi_abi
 #if defined (__APPLE__)
 #define FFI_TARGET_SPECIFIC_VARIADIC
 #define FFI_EXTRA_CIF_FIELDS unsigned aarch64_nfixedargs
-#elif !defined(_M_ARM64)
+#elif !defined(ARM_WIN64)
 /* iOS and Windows reserve x18 for the system.  Disable Go closures until
    a new static chain is chosen.  */
 #define FFI_GO_CLOSURES 1
 #endif
 
-#ifndef _M_ARM64
+#ifndef ARM_WIN64
 /* No complex type on Windows */
 #define FFI_TARGET_HAS_COMPLEX_TYPE
 #endif
diff --git a/src/arm/ffi.c b/src/arm/ffi.c
index 1111111..2222222 100644
--- a/src/arm/ffi.c
+++ b/src/arm/ffi.c
@@ -28,7 +28,7 @@
    DEALINGS IN THE SOFTWARE.
    ----------------------------------------------------------------------- */
 
-#if defined(__arm__) || defined(_M_ARM)
+#if defined(__arm__) || defined(ARM_WIN32)
 #include <fficonfig.h>
 #include <ffi.h>
 #include <ffi_common.h>
@@ -36,7 +36,7 @@
 #include <stdlib.h>
 #include "internal.h"
 
-#if defined(_MSC_VER) && defined(_M_ARM)
+#ifdef ARM_WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
@@ -48,7 +48,7 @@
 #endif
 
 #else
-#ifndef _M_ARM
+#ifndef ARM_WIN32
 extern unsigned int ffi_arm_trampoline[2] FFI_HIDDEN;
 #else
 extern unsigned int ffi_arm_trampoline[3] FFI_HIDDEN;
@@ -592,24 +592,26 @@ ffi_prep_closure_loc (ffi_closure * closure,
   config[1] = closure_func;
 #else
 
-#ifndef _M_ARM
+#ifndef ARM_WIN32
   memcpy(closure->tramp, ffi_arm_trampoline, 8);
-#else
+#elif defined(_MSC_VER)
   // cast away function type so MSVC doesn't set the lower bit of the function pointer
   memcpy(closure->tramp, (void*)((uintptr_t)ffi_arm_trampoline & 0xFFFFFFFE), FFI_TRAMPOLINE_CLOSURE_OFFSET);
+#else
+  memcpy(closure->tramp, ffi_arm_trampoline, FFI_TRAMPOLINE_CLOSURE_OFFSET);
 #endif
 
 #if defined (__QNX__)
   msync(closure->tramp, 8, 0x1000000);	/* clear data map */
   msync(codeloc, 8, 0x1000000);	/* clear insn map */
-#elif defined(_MSC_VER)
+#elif defined(ARM_WIN32)
   FlushInstructionCache(GetCurrentProcess(), closure->tramp, FFI_TRAMPOLINE_SIZE);
 #else
   __clear_cache(closure->tramp, closure->tramp + 8);	/* clear data map */
   __clear_cache(codeloc, codeloc + 8);			/* clear insn map */
 #endif
-#ifdef _M_ARM
-  *(void(**)(void))(closure->tramp + FFI_TRAMPOLINE_CLOSURE_FUNCTION) = closure_func;
+#ifdef ARM_WIN32
+  *(void (**)(void))(closure->tramp + FFI_TRAMPOLINE_CLOSURE_FUNCTION) = closure_func;
 #else
   *(void (**)(void))(closure->tramp + 8) = closure_func;
 #endif
@@ -851,4 +853,4 @@ layout_vfp_args (ffi_cif * cif)
     }
 }
 
-#endif /* __arm__ or _M_ARM */
+#endif /* defined(__arm__) || defined(ARM_WIN32) */
diff --git a/src/arm/ffitarget.h b/src/arm/ffitarget.h
index 1111111..2222222 100644
--- a/src/arm/ffitarget.h
+++ b/src/arm/ffitarget.h
@@ -43,7 +43,7 @@ typedef enum ffi_abi {
   FFI_SYSV,
   FFI_VFP,
   FFI_LAST_ABI,
-#if defined(__ARM_PCS_VFP) || defined(_M_ARM)
+#if defined(__ARM_PCS_VFP) || defined(ARM_WIN32)
   FFI_DEFAULT_ABI = FFI_VFP,
 #else
   FFI_DEFAULT_ABI = FFI_SYSV,
@@ -56,8 +56,13 @@ typedef enum ffi_abi {
   unsigned short vfp_reg_free, vfp_nargs;	\
   signed char vfp_args[16]			\
 
+#ifdef __MINGW32__
+#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
+#endif
+
 #define FFI_TARGET_SPECIFIC_VARIADIC
-#ifndef _M_ARM
+#ifndef ARM_WIN32
+/* No complex type on Windows */
 #define FFI_TARGET_HAS_COMPLEX_TYPE
 #endif
 
@@ -77,7 +82,7 @@ typedef enum ffi_abi {
 #endif
 
 #else
-#ifdef _MSC_VER
+#ifdef ARM_WIN32
 #define FFI_TRAMPOLINE_SIZE 16
 #define FFI_TRAMPOLINE_CLOSURE_FUNCTION 12
 #else
diff --git a/src/arm/sysv.S b/src/arm/sysv.S
index 1111111..2222222 100644
--- a/src/arm/sysv.S
+++ b/src/arm/sysv.S
@@ -94,7 +94,10 @@
 
 /* Aid in defining a jump table with 8 bytes between entries.  */
 /* ??? The clang assembler doesn't handle .if with symbolic expressions.  */
-#ifdef __clang__
+#ifdef ARM_WIN32
+# define E(index)				\
+	.balign	8
+#elif defined(__clang__)
 # define E(index)
 #else
 # define E(index)				\
@@ -105,7 +108,11 @@
 
 	.text
 	.syntax unified
+#ifdef ARM_WIN32
+	.thumb
+#else
 	.arm
+#endif
 
 #ifndef __clang__
 	/* We require interworking on LDM, which implies ARMv5T,
@@ -128,7 +135,11 @@ ARM_FUNC_START(ffi_call_VFP)
 	cfi_startproc
 
 	cmp	r3, #3			@ load only d0 if possible
-#ifdef __clang__
+#ifdef ARM_WIN32
+	ITE LE
+	vldrle d0, [r0]
+	vldmgt r0, {d0-d7}
+#elif defined(__clang__)
 	vldrle d0, [sp]
 	vldmgt sp, {d0-d7}
 #else
@@ -167,8 +178,16 @@ ARM_FUNC_START(ffi_call_SYSV)
 	cfi_def_cfa_register(sp)
 
 	@ Store values stored in registers.
+#ifdef ARM_WIN32
+	.balign 8
+	lsl	r3, #3
+	add	r3, r3, pc
+	add	r3, #8
+	mov	pc, r3
+#else
 	.align	3
 	add	pc, pc, r3, lsl #3
+#endif
 	nop
 0:
 E(ARM_TYPE_VFP_S)
@@ -202,6 +221,9 @@ E(ARM_TYPE_VOID)
 	pop	{fp,pc}
 	nop
 E(ARM_TYPE_STRUCT)
+#ifdef ARM_WIN32
+	cmp	r3, #ARM_TYPE_STRUCT
+#endif
 	pop	{fp,pc}
 
 	cfi_endproc
@@ -227,6 +249,9 @@ ARM_FUNC_END(ffi_go_closure_SYSV)
 ARM_FUNC_START(ffi_closure_SYSV)
 	UNWIND(.fnstart)
 	cfi_startproc
+#ifdef ARM_WIN32
+	pop	{r0,ip}			@ restore fp (r0 is used for stack alignment)
+#endif
 	stmdb	sp!, {r0-r3}			@ save argument regs
 	cfi_adjust_cfa_offset(16)
 
@@ -240,6 +265,10 @@ ARM_FUNC_START(ffi_closure_SYSV)
 	add	ip, sp, #16			@ compute entry sp
 	sub	sp, sp, #64+32			@ allocate frame
 	cfi_adjust_cfa_offset(64+32)
+
+#ifdef ARM_WIN32
+	mov	r3, sp			@ set frame parameter
+#endif
 	stmdb	sp!, {ip,lr}
 
 	/* Remember that EABI unwind info only applies at call sites.
@@ -249,13 +278,23 @@ ARM_FUNC_START(ffi_closure_SYSV)
 	cfi_adjust_cfa_offset(8)
 	cfi_rel_offset(lr, 4)
 
+#ifndef ARM_WIN32
 	add	r3, sp, #8			@ load frame
+#endif
 	bl	CNAME(ffi_closure_inner_SYSV)
 
 	@ Load values returned in registers.
 	add	r2, sp, #8+64			@ load result
+#ifdef ARM_WIN32
+	bl	CNAME(ffi_closure_ret)			@ move result to correct register or memory for type
+
+	pop	{ip,lr}
+	mov	sp, ip			@ restore stack pointer
+	mov	pc, lr
+#else
 	adr	r3, CNAME(ffi_closure_ret)
 	add	pc, r3, r0, lsl #3
+#endif
 	cfi_endproc
 	UNWIND(.fnend)
 ARM_FUNC_END(ffi_closure_SYSV)
@@ -274,6 +313,9 @@ ARM_FUNC_END(ffi_go_closure_VFP)
 ARM_FUNC_START(ffi_closure_VFP)
 	UNWIND(.fnstart)
 	cfi_startproc
+#ifdef ARM_WIN32
+	pop	{r0,ip}			@ restore fp (r0 is used for stack alignment)
+#endif
 	stmdb	sp!, {r0-r3}			@ save argument regs
 	cfi_adjust_cfa_offset(16)
 
@@ -284,13 +326,22 @@ ARM_FUNC_START(ffi_closure_VFP)
 	ldr	r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  @ load fun
 	ldr	r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  @ load user_data
 0:
-	add	ip, sp, #16
+	add	ip, sp, #16			@ compute entry sp
+#ifdef ARM_WIN32
+	sub	sp, sp, #32			@ save space for closure_frame->result
+	cfi_adjust_cfa_offset(32)
+
+	vstmdb	sp!, {d0-d7}		@ push closure_frame->vfp_space
+
+	mov	r3, sp		@ save closure_frame
+#else
 	sub	sp, sp, #64+32			@ allocate frame
 	cfi_adjust_cfa_offset(64+32)
 #ifdef __clang__
 	vstm sp, {d0-d7}
 #else
 	stc	p11, cr0, [sp], {16}		@ vstm sp, {d0-d7}
+#endif
 #endif
 	stmdb	sp!, {ip,lr}
 
@@ -299,13 +350,22 @@ ARM_FUNC_START(ffi_closure_VFP)
 	cfi_adjust_cfa_offset(8)
 	cfi_rel_offset(lr, 4)
 
+#ifndef ARM_WIN32
 	add	r3, sp, #8			@ load frame
+#endif
 	bl	CNAME(ffi_closure_inner_VFP)
 
 	@ Load values returned in registers.
 	add	r2, sp, #8+64			@ load result
+#ifdef ARM_WIN32
+	bl	CNAME(ffi_closure_ret)
+	pop	{ip,lr}
+	mov	sp, ip			@ restore stack pointer
+	mov	pc, lr
+#else
 	adr	r3, CNAME(ffi_closure_ret)
 	add	pc, r3, r0, lsl #3
+#endif
 	cfi_endproc
 	UNWIND(.fnend)
 ARM_FUNC_END(ffi_closure_VFP)
@@ -316,6 +376,15 @@ ARM_FUNC_END(ffi_closure_VFP)
 
 ARM_FUNC_START_LOCAL(ffi_closure_ret)
 	cfi_startproc
+#ifdef ARM_WIN32
+	stmdb	sp!, {fp,lr}
+
+	.balign	8
+	lsl	r0, #3
+	add	r0, r0, pc
+	add	r0, #8
+	mov	pc, r0
+#endif
 	cfi_rel_offset(sp, 0)
 	cfi_rel_offset(lr, 4)
 0:
@@ -325,32 +394,38 @@ E(ARM_TYPE_VFP_S)
 #else
 	ldc	p10, cr0, [r2]			@ vldr s0, [r2]
 #endif
-	ldm	sp, {sp,pc}
+	b call_epilogue
 E(ARM_TYPE_VFP_D)
 #ifdef __clang__
 	vldr d0, [r2]
 #else
 	ldc	p11, cr0, [r2]			@ vldr d0, [r2]
 #endif
-	ldm	sp, {sp,pc}
+	b call_epilogue
 E(ARM_TYPE_VFP_N)
 #ifdef __clang__
 	vldm r2, {d0-d3}
 #else
 	ldc	p11, cr0, [r2], {8}		@ vldm r2, {d0-d3}
 #endif
-	ldm	sp, {sp,pc}
+	b call_epilogue
 E(ARM_TYPE_INT64)
 	ldr	r1, [r2, #4]
 	nop
 E(ARM_TYPE_INT)
 	ldr	r0, [r2]
-	ldm	sp, {sp,pc}
+	b call_epilogue
 E(ARM_TYPE_VOID)
-	ldm	sp, {sp,pc}
+	b call_epilogue
 	nop
 E(ARM_TYPE_STRUCT)
+	b call_epilogue
+call_epilogue:
+#ifdef ARM_WIN32
+	pop	{fp,pc}
+#else
 	ldm	sp, {sp,pc}
+#endif
 	cfi_endproc
 ARM_FUNC_END(ffi_closure_ret)
 
@@ -373,6 +448,9 @@ ARM_FUNC_END(ffi_closure_trampoline_table_page)
 
 ARM_FUNC_START(ffi_arm_trampoline)
 0:	adr	ip, 0b
+#ifdef ARM_WIN32
+	stmdb	sp!, {r0, ip}
+#endif
 	ldr	pc, 1f
 1:	.long	0
 ARM_FUNC_END(ffi_arm_trampoline)
diff --git a/src/closures.c b/src/closures.c
index 1111111..2222222 100644
--- a/src/closures.c
+++ b/src/closures.c
@@ -123,7 +123,7 @@ ffi_closure_free (void *ptr)
 #  define FFI_MMAP_EXEC_WRIT 1
 #  define HAVE_MNTENT 1
 # endif
-# if defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)
+# if defined(X86_WIN32) || defined(X86_WIN64) || defined(ARM_WIN32) || defined(ARM_WIN64) || defined(__OS2__)
 /* Windows systems may have Data Execution Protection (DEP) enabled, 
    which requires the use of VirtualMalloc/VirtualFree to alloc/free
    executable memory. */
@@ -386,7 +386,7 @@ ffi_closure_free (void *ptr)
 #endif
 #include <string.h>
 #include <stdio.h>
-#if !defined(X86_WIN32) && !defined(X86_WIN64) && !defined(_M_ARM64)
+#if !defined(X86_WIN32) && !defined(X86_WIN64) && !defined(ARM_WIN32) && !defined(ARM_WIN64)
 #ifdef HAVE_MNTENT
 #include <mntent.h>
 #endif /* HAVE_MNTENT */
@@ -512,7 +512,7 @@ static int dlmalloc_trim(size_t) MAYBE_UNUSED;
 static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;
 static void dlmalloc_stats(void) MAYBE_UNUSED;
 
-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
+#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(ARM_WIN32) || defined(ARM_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
 /* Use these for mmap and munmap within dlmalloc.c.  */
 static void *dlmmap(void *, size_t, int, int, int, off_t);
 static int dlmunmap(void *, size_t);
@@ -526,7 +526,7 @@ static int dlmunmap(void *, size_t);
 #undef mmap
 #undef munmap
 
-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
+#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(ARM_WIN32) || defined(ARM_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
 
 /* A mutex used to synchronize access to *exec* variables in this file.  */
 static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -908,7 +908,7 @@ segment_holding_code (mstate m, char* addr)
 }
 #endif
 
-#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */
+#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(ARM_WIN32) || defined(ARM_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */
 
 /* Allocate a chunk of memory with the given size.  Returns a pointer
    to the writable address, and sets *CODE to the executable
diff --git a/src/prep_cif.c b/src/prep_cif.c
index 1111111..2222222 100644
--- a/src/prep_cif.c
+++ b/src/prep_cif.c
@@ -129,7 +129,7 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,
   cif->rtype = rtype;
 
   cif->flags = 0;
-#ifdef _M_ARM64
+#ifdef ARM_WIN64
   cif->is_variadic = isvariadic;
 #endif
 #if HAVE_LONG_DOUBLE_VARIANT
diff --git a/src/x86/ffitarget.h b/src/x86/ffitarget.h
index 1111111..2222222 100644
--- a/src/x86/ffitarget.h
+++ b/src/x86/ffitarget.h
@@ -46,8 +46,10 @@
 
 #ifdef X86_WIN64
 #define FFI_SIZEOF_ARG 8
+#ifdef __MINGW32__
 #define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
 #endif
+#endif
 
 #define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
 #ifndef _MSC_VER
