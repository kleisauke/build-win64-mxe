This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 8 Oct 2019 13:00:00 +0200
Subject: [PATCH 1/1] Squashed commit of the following:

commit 71b557cfc1d83f1df1f511ecf38a870daf35a1b7
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Oct 7 15:42:29 2019 +0100

    remove "minimise" handler from tiffload

    We need to be able to disconnect the underlying fd and we can't do that
    without making our own input handler for files. Implement this when we add
    input objects.

commit c92a71cb98920440c6c394c41a462253920a764a
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Oct 7 14:58:49 2019 +0100

    fix pngload segv on header error

commit 3510c515f2294578a4808034655ab1042ab7363a
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Oct 7 13:30:19 2019 +0100

    oop deleted one png init too many

commit 2d374c3114f8519d72bac96aa726a4e1b03ddb14
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Oct 7 10:01:15 2019 +0100

    pngload supports restart after minimise

    plus a test

commit d290c971ab3b6851b46ddaa092abd5273e4da645
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Sep 11 14:56:32 2019 +0100

    reorganise vipspng a little

    so we only set max malloc in one place

    see https://github.com/libvips/libvips/pull/1424

commit e233698c2b72b963e79d72186c845ea2b8c13f7f
Author: Matt Drollette <matt@drollette.com>
Date:   Tue Sep 10 12:31:11 2019 -0500

    also set png max chunk malloc when reading buffer

commit 3eca1ff3ee372e131edb0cadca82903b0ff1c9ac
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Oct 6 19:29:10 2019 +0100

    heifload passes the new descriptor tests

commit 3f1eb2c7dd467ad9ee8843e156459479f2cc02ac
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Oct 6 18:27:40 2019 +0100

    test pdfload in te new desc tester

    and fix a couple of small issues

commit c1921b0ad117fc5a820ba5e12720cb6a676e224d
Author: John Cupitt <jcupitt@gmail.com>
Date:   Fri Oct 4 17:44:25 2019 +0100

    add a test for file descriptors

    verify new loader behaviour with minimise

commit c328b089b138fc5c1954340d914195478208d510
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Oct 3 16:40:52 2019 +0100

    jpegload restart after minimise

    after minimise, we need to reopen the underlying file

    passes pytest but a proper test is still to come

    https://github.com/libvips/libvips/issues/1370

commit 08308759170fa66196c4ca07b012bab7bd95ffe9
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Oct 3 13:16:37 2019 +0100

    add restart to heifload

    heifload will restart read if necessary after minimise

    see https://github.com/libvips/libvips/issues/1370

commit 4f1e57c04027a7854ab43c649bddd74b5e53031a
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Sep 26 18:07:18 2019 +0100

    add restart after minimise support to gifload

    see https://github.com/libvips/libvips/issues/1370#issuecomment-533169856

commit e16e4abeda1aeadbbfe61db9dadba3378719956a
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Sep 19 18:09:19 2019 +0100

    make pdfload header a proper vfunc

    _buffer was not inheriting it correctly

commit 0323b77666769122e937704269dc4c49648ccab9
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Sep 19 17:04:42 2019 +0100

    pdfload reopens after minimise if necessary

    We were using "minimise" to close pdf input early, but this will break
    programs which make several output images from one sequential input
    image. For example, loading all pages of a PDF as a toilet-roll image,
    then saving pages as a set of PNGs.

    This patch adds vfuncs for open and close, and makes _generate reopen
    the input if necessary.

    We will need similar patches for pdfiumload, gifload, gifnsload,
    tiffload etc.

    see https://github.com/libvips/libvips/issues/1370#issuecomment-533169856

commit a1ed6c7f6c53d10b6b934d6b7a25dfadcfebd66f
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Sep 1 12:54:47 2019 +0100

    improve GIF edarly close again

    We were trying to keep the FILE open for gifload between header and
    load, but this meant some corrupt GIFs could keep the file open longer
    than they should.

    Instead, make close into a vfunc and always close between header and
    load.

    see https://github.com/libvips/libvips/issues/1370#issuecomment-526829415

commit 5ef14db544b3e20195dd5a213f086f3013180d23
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Jul 28 11:34:40 2019 +0100

    put close-on-last-line back for jpg/tif/png

    consider something like:

    $ vips arrayjoin "$(echo *.jpg)" x.tif --across 10 --vips-progress

    close on minimise won't close until the whole pipeline finishes, so
    we'll need to keep every input file open

    close on last line will shut down inputs as we are done with them, so we
    save a lot of file descriptors

    this patch puts close-on-last-line back for jpg/tif/png

commit 67f3cc13ecc6f299fa88044f685c0331441d0344
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Jul 25 11:34:50 2019 +0100

    remove old close-early comment from openexr load

    no longer relevant in the world of minimise

commit 53e0bc66984576da844e4bc4586a5afa9ad92c8c
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Jul 25 11:31:21 2019 +0100

    pdfload / pdfiumload use minimise to close early

    see https://github.com/libvips/libvips/issues/1370#issuecomment-514949292

commit 9373d63d6edd908da1da4039ce1a1caa592a7dce
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 18:17:54 2019 +0100

    better early close for gif header read

commit 265cb8dffd279ffa35985296842d4dfa077096b0
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 18:00:37 2019 +0100

    close heif early for header read err

    we were only closing early if there was an error during pixel read

commit e11811a316baff56b2ed2091aafe686f70709a0c
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 17:43:14 2019 +0100

    fix early close for corrupt gifs

    we were not closing early on a read error during gif scan

    see https://github.com/libvips/libvips/issues/1370#issuecomment-514172899

commit 28090d614ff202f7bc229dd1384e99c00b69c5ad
Author: John Cupitt <jcupitt@gmail.com>
Date:   Tue Jul 23 12:06:35 2019 +0100

    oops logic mixup

    Kleis pointed out a suprious return in png load minimise.

    see https://github.com/libvips/libvips/issues/1370#issuecomment-513706480

commit 4f2f4b4577c246243da1aff4c6b02363c5289bee
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Jul 21 12:29:25 2019 +0100

    add gif, heif, rad, webp early close

commit 2c654060f95d95f5c5eeb493701ec5aafe539ee3
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sat Jul 20 16:31:30 2019 +0100

    experiment with a different early-close strategy

    We close loaders early in order to save file handles, and on Windows to
    make sure that files can be deleted as soon as possible.

    Currently loaders do this by watching the Y coordinate of requests and
    freeing the fd when the final line of the file is fetched. This is messy
    and does not always work, since there are cases when the final line is
    not fetched.

    Instead, this patch gets loaders to listen for "minimise" on their
    output and close on that. This signal is emitted on all upstream images
    whenever a threadpool finishes a scan of an image and is usually used to
    trim caches after computation.

    See https://github.com/libvips/libvips/issues/1370

diff --git a/libvips/conversion/sequential.c b/libvips/conversion/sequential.c
index 1111111..2222222 100644
--- a/libvips/conversion/sequential.c
+++ b/libvips/conversion/sequential.c
@@ -195,6 +195,11 @@ vips_sequential_build( VipsObject *object )
 	if( vips_linecache( sequential->in, &t, 
 		"tile_height", sequential->tile_height,
 		"access", VIPS_ACCESS_SEQUENTIAL,
+		/* We need seq caches to persist across minimise, in case
+		 * someone is trying to read an image with a series of crop
+		 * operations.
+		 */
+		"persistent", TRUE,
 		NULL ) )
 		return( -1 );
 
diff --git a/libvips/foreign/gifload.c b/libvips/foreign/gifload.c
index 1111111..2222222 100644
--- a/libvips/foreign/gifload.c
+++ b/libvips/foreign/gifload.c
@@ -22,9 +22,16 @@
  * 	- init pages to 0 before load
  * 14/2/19
  * 	- rework as a sequential loader ... simpler, much lower mem use
+ * 24/7/19
+ * 	- close early on minimise 
+ * 	- close early on error
  * 23/8/18
  * 	- allow GIF read errors during header scan
  * 	- better feof() handling
+ * 27/8/19
+ * 	- check image and frame bounds, since giflib does not
+ * 1/9/19
+ * 	- improve early close again
  */
 
 /*
@@ -199,9 +206,19 @@ typedef struct _VipsForeignLoadGif {
 typedef struct _VipsForeignLoadGifClass {
 	VipsForeignLoadClass parent_class;
 
-	/* Close and reopen gif->file.
+	/* Open the reader (eg. the FILE we are reading from). giflib is
+	 * created in _header and freed in _dispose.
 	 */
 	int (*open)( VipsForeignLoadGif *gif );
+
+	/* Rewind the reader, eg. fseek() back to the start.
+	 */
+	void (*rewind)( VipsForeignLoadGif *gif );
+
+	/* Close the reader.
+	 */
+	void (*close)( VipsForeignLoadGif *gif );
+
 } VipsForeignLoadGifClass;
 
 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadGif, vips_foreign_load_gif, 
@@ -296,24 +313,82 @@ vips_foreign_load_gif_error( VipsForeignLoadGif *gif )
 		vips_foreign_load_gif_error_vips( gif, error ); 
 }
 
-static void
-vips_foreign_load_gif_close( VipsForeignLoadGif *gif )
+/* Shut down giflib plus any underlying file resource.
+ */
+static int
+vips_foreign_load_gif_close_giflib( VipsForeignLoadGif *gif )
 {
+	VipsForeignLoadGifClass *class = VIPS_FOREIGN_LOAD_GIF_GET_CLASS( gif );
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_close_giflib:\n" );
+
 #ifdef HAVE_GIFLIB_5
 	if( gif->file ) {
-		int error; 
+		int error;
 
-		if( DGifCloseFile( gif->file, &error ) == GIF_ERROR ) 
+		if( DGifCloseFile( gif->file, &error ) == GIF_ERROR ) {
 			vips_foreign_load_gif_error_vips( gif, error );
+			gif->file = NULL;
+
+			return( -1 );
+		}
 		gif->file = NULL;
 	}
-#else 
+#else
 	if( gif->file ) {
-		if( DGifCloseFile( gif->file ) == GIF_ERROR ) 
-			vips_foreign_load_gif_error_vips( gif, GifLastError() ); 
+		if( DGifCloseFile( gif->file ) == GIF_ERROR ) {
+			vips_foreign_load_gif_error_vips( gif, GifLastError() );
+			gif->file = NULL;
+
+			return( -1 );
+		}
 		gif->file = NULL;
 	}
 #endif
+
+	class->close( gif );
+
+	return( 0 );
+}
+
+/* Open any underlying file resource, then giflib.
+ */
+static int
+vips_foreign_load_gif_open_giflib( VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifClass *class = VIPS_FOREIGN_LOAD_GIF_GET_CLASS( gif );
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_open_giflib:\n" );
+
+	if( class->open( gif ) )
+		return( -1 );
+
+	/* Must always rewind before opening giflib again.
+	 */
+	class->rewind( gif );
+
+#ifdef HAVE_GIFLIB_5
+{
+	int error;
+
+	if( !(gif->file = DGifOpen( gif, gif->read_func, &error )) ) {
+		vips_foreign_load_gif_error_vips( gif, error );
+		(void) vips_foreign_load_gif_close_giflib( gif );
+		return( -1 );
+	}
+}
+#else 
+	if( !(gif->file = DGifOpen( gif, gif->read_func )) ) { 
+		vips_foreign_load_gif_error_vips( gif, GifLastError() ); 
+		(void) vips_foreign_load_gif_close_giflib( gif );
+		return( -1 ); 
+	}
+#endif
+
+	gif->eof = FALSE;
+	gif->current_page = 0;
+
+	return( 0 );
 }
 
 static void
@@ -321,12 +396,14 @@ vips_foreign_load_gif_dispose( GObject *gobject )
 {
 	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) gobject;
 
-	vips_foreign_load_gif_close( gif ); 
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_dispose:\n" );
+
+	vips_foreign_load_gif_close_giflib( gif );
 
 	VIPS_UNREF( gif->frame ); 
 	VIPS_UNREF( gif->previous ); 
 	VIPS_FREE( gif->comment ); 
-	VIPS_FREE( gif->line ) 
+	VIPS_FREE( gif->line );
 
 	G_OBJECT_CLASS( vips_foreign_load_gif_parent_class )->
 		dispose( gobject );
@@ -596,17 +673,13 @@ vips_foreign_load_gif_set_header( VipsForeignLoadGif *gif, VipsImage *image )
  * Don't flag errors during header scan. Many GIFs do not follow spec.
  */
 static int
-vips_foreign_load_gif_header( VipsForeignLoad *load )
+vips_foreign_load_gif_scan( VipsForeignLoadGif *gif )
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadGifClass *gif_class = 
-		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
 
 	GifRecordType record;
 
-	if( gif_class->open( gif ) )
-		return( -1 );
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_scan:\n" );
 
 	gif->n_pages = 0;
 
@@ -623,7 +696,7 @@ vips_foreign_load_gif_header( VipsForeignLoad *load )
 			break;
 
 		case EXTENSION_RECORD_TYPE:
-			/* We will need to fetch the extensions to check for
+			/* We need to fetch the extensions to check for
 			 * cmaps and transparency.
 			 */
 			(void) vips_foreign_load_gif_scan_extension( gif );
@@ -652,10 +725,48 @@ vips_foreign_load_gif_header( VipsForeignLoad *load )
 		return( -1 ); 
 	}
 
-	/* And set the output vips header from what we've learned.
+	return( 0 );
+}
+
+/* Scan the GIF and set the libvips header. We always close after scan, even
+ * on an error.
+ */
+static int
+vips_foreign_load_gif_header( VipsForeignLoad *load )
+{
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
+	VipsForeignLoadGif *gif = VIPS_FOREIGN_LOAD_GIF( load );
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_header: %p\n", gif );
+
+	if( vips_foreign_load_gif_open_giflib( gif ) )
+		return( -1 );
+
+	/* giflib does no checking of image dimensions, not even for 0.
 	 */
-	if( vips_foreign_load_gif_set_header( gif, load->out ) )
+	if( gif->file->SWidth <= 0 ||
+		gif->file->SWidth > VIPS_MAX_COORD ||
+		gif->file->SHeight <= 0 ||
+		gif->file->SHeight > VIPS_MAX_COORD ) {
+		vips_error( class->nickname, 
+			"%s", _( "image size out of bounds" ) );
+		(void) vips_foreign_load_gif_close_giflib( gif );
+
+		return( -1 );
+	}
+
+	/* Allocate a line buffer now that we have the GIF width.
+	 */
+	if( !(gif->line = 
+		VIPS_ARRAY( NULL, gif->file->SWidth, GifPixelType )) ||
+		vips_foreign_load_gif_scan( gif ) ||
+		vips_foreign_load_gif_set_header( gif, load->out ) ) {
+		(void) vips_foreign_load_gif_close_giflib( gif );
+
 		return( -1 );
+	}
+
+	(void) vips_foreign_load_gif_close_giflib( gif );
 
 	return( 0 );
 }
@@ -931,9 +1042,22 @@ vips_foreign_load_gif_generate( VipsRegion *or,
 {
         VipsRect *r = &or->valid;
 	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) a;
+	VipsForeignLoadGifClass *class = VIPS_FOREIGN_LOAD_GIF_GET_CLASS( gif );
 
 	int y;
 
+#ifdef DEBUG_VERBOSE
+	printf( "vips_foreign_load_gif_generate: %p "
+		"left = %d, top = %d, width = %d, height = %d\n",
+		gif,
+		r->left, r->top, r->width, r->height );
+#endif /*DEBUG_VERBOSE*/
+
+	/* May have been minimised. Reopen the fp if necessary.
+	 */
+	if( class->open( gif ) )
+		return( -1 );
+
 	for( y = 0; y < r->height; y++ ) {
 		/* The page for this output line, and the line number in page.
 		 */
@@ -1005,21 +1129,25 @@ vips_foreign_load_gif_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+vips_foreign_load_gif_minimise( VipsObject *object, VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifClass *class = VIPS_FOREIGN_LOAD_GIF_GET_CLASS( gif );
+
+	class->close( gif );
+}
+
 static int
 vips_foreign_load_gif_load( VipsForeignLoad *load )
 {
-	VipsForeignLoadGifClass *class = 
-		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;
-	VipsImage **t = (VipsImage **) 
+	VipsForeignLoadGif *gif = VIPS_FOREIGN_LOAD_GIF( load );
+	VipsImage **t = (VipsImage **)
 		vips_object_local_array( VIPS_OBJECT( load ), 4 );
 
-	/* Rewind.
-	 */
-	if( class->open( gif ) )
-		return( -1 );
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_load: %p\n", gif );
 
-	VIPS_DEBUG_MSG( "vips_foreign_load_gif_load:\n" ); 
+	if( vips_foreign_load_gif_open_giflib( gif ) )
+		return( -1 );
 
 	/* Make the memory image we accumulate pixels in. We always accumulate
 	 * to RGBA, then trim down to whatever the output image needs on
@@ -1048,6 +1176,11 @@ vips_foreign_load_gif_load( VipsForeignLoad *load )
 	if( vips_foreign_load_gif_set_header( gif, t[0] ) )
 		return( -1 );
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_gif_minimise ), gif ); 
+
 	/* Strips 8 pixels high to avoid too many tiny regions.
 	 */
 	if( vips_image_generate( t[0], 
@@ -1064,45 +1197,17 @@ vips_foreign_load_gif_load( VipsForeignLoad *load )
 static int
 vips_foreign_load_gif_open( VipsForeignLoadGif *gif )
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
+	return( 0 );
+}
 
-#ifdef HAVE_GIFLIB_5
+static void
+vips_foreign_load_gif_rewind( VipsForeignLoadGif *gif )
 {
-	int error;
-
-	if( !(gif->file = DGifOpen( gif, gif->read_func, &error )) ) {
-		vips_foreign_load_gif_error_vips( gif, error );
-		return( -1 ); 
-	}
 }
-#else 
-	if( !(gif->file = DGifOpen( gif, gif->read_func )) ) { 
-		vips_foreign_load_gif_error_vips( gif, GifLastError() ); 
-		return( -1 ); 
-	}
-#endif
-
-	gif->eof = FALSE;
-	gif->current_page = 0;
 
-	/* giflib does no checking of image dimensions, not even for 0.
-	 */
-	if( gif->file->SWidth <= 0 ||
-		gif->file->SWidth > VIPS_MAX_COORD ||
-		gif->file->SHeight <= 0 ||
-		gif->file->SHeight > VIPS_MAX_COORD ) {
-		vips_error( class->nickname, 
-			"%s", _( "image size out of bounds" ) );
-		return( -1 );
-	}
-
-	/* Allocate a line buffer now that we have the GIF width.
-	 */
-	VIPS_FREE( gif->line ) 
-	if( !(gif->line = VIPS_ARRAY( NULL, gif->file->SWidth, GifPixelType )) )
-		return( -1 ); 
-
-	return( 0 );
+static void
+vips_foreign_load_gif_close( VipsForeignLoadGif *gif )
+{
 }
 
 static void
@@ -1111,23 +1216,24 @@ vips_foreign_load_gif_class_init( VipsForeignLoadGifClass *class )
 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 	VipsObjectClass *object_class = (VipsObjectClass *) class;
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-	VipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;
 
 	gobject_class->dispose = vips_foreign_load_gif_dispose;
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
-	gif_class->open = vips_foreign_load_gif_open;
-	load_class->header = vips_foreign_load_gif_header;
-	load_class->load = vips_foreign_load_gif_load;
-
 	object_class->nickname = "gifload_base";
 	object_class->description = _( "load GIF with giflib" );
 
-	load_class->get_flags_filename = 
+	load_class->header = vips_foreign_load_gif_header;
+	load_class->load = vips_foreign_load_gif_load;
+	load_class->get_flags_filename =
 		vips_foreign_load_gif_get_flags_filename;
 	load_class->get_flags = vips_foreign_load_gif_get_flags;
 
+	class->open = vips_foreign_load_gif_open;
+	class->rewind = vips_foreign_load_gif_rewind;
+	class->close = vips_foreign_load_gif_close;
+
 	VIPS_ARG_INT( class, "page", 20,
 		_( "Page" ),
 		_( "Load this page from the file" ),
@@ -1166,6 +1272,10 @@ typedef struct _VipsForeignLoadGifFile {
 	 */
 	FILE *fp;
 
+	/* If we close and reopen, save the ftell point here.
+	 */
+	long seek_position;
+
 } VipsForeignLoadGifFile;
 
 typedef VipsForeignLoadGifClass VipsForeignLoadGifFileClass;
@@ -1173,17 +1283,6 @@ typedef VipsForeignLoadGifClass VipsForeignLoadGifFileClass;
 G_DEFINE_TYPE( VipsForeignLoadGifFile, vips_foreign_load_gif_file, 
 	vips_foreign_load_gif_get_type() );
 
-static void
-vips_foreign_load_gif_file_dispose( GObject *gobject )
-{
-	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gobject;
-
-	VIPS_FREEF( fclose, file->fp ); 
-
-	G_OBJECT_CLASS( vips_foreign_load_gif_file_parent_class )->
-		dispose( gobject );
-}
-
 /* Our input function for file open. We can't use DGifOpenFileName(), since
  * that just calls open() and won't work with unicode on win32. We can't use
  * DGifOpenFileHandle() since that's an fd from open() and you can't pass those
@@ -1201,29 +1300,67 @@ vips_giflib_file_read( GifFileType *gfile, GifByteType *buffer, int n )
 	return( (int) fread( (void *) buffer, 1, n, file->fp ) );
 }
 
+/* We have to have _open() as a vfunc since we want to be able to reopen in
+ * _generate if we have been closed during _minimise. 
+ */
 static int
 vips_foreign_load_gif_file_open( VipsForeignLoadGif *gif )
 {
 	VipsForeignLoad *load = (VipsForeignLoad *) gif;
 	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;
 
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_file_open:\n" );
+
 	if( !file->fp ) {
-		if( !(file->fp = 
-			vips__file_open_read( file->filename, NULL, FALSE )) ) 
-			return( -1 ); 
+		if( !(file->fp =
+			vips__file_open_read( file->filename, NULL, FALSE )) )
+			return( -1 );
+
+		/* Restore the read point if we are reopening.
+		 */
+		if( file->seek_position != -1 )
+			fseek( file->fp, file->seek_position, SEEK_SET );
 
 		VIPS_SETSTR( load->out->filename, file->filename );
+		gif->read_func = vips_giflib_file_read;
 	}
-	else 
-		rewind( file->fp );
-
-	vips_foreign_load_gif_close( gif );
-	gif->read_func = vips_giflib_file_read;
 
 	return( VIPS_FOREIGN_LOAD_GIF_CLASS( 
 		vips_foreign_load_gif_file_parent_class )->open( gif ) );
 }
 
+static void
+vips_foreign_load_gif_file_rewind( VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_file_rewind:\n" );
+
+	if( file->fp ) {
+		file->seek_position = 0;
+		fseek( file->fp, file->seek_position, SEEK_SET );
+	}
+
+	VIPS_FOREIGN_LOAD_GIF_CLASS(
+		vips_foreign_load_gif_file_parent_class )->rewind( gif );
+}
+
+static void
+vips_foreign_load_gif_file_close( VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_file_close:\n" );
+
+	if( file->fp ) {
+		file->seek_position = ftell( file->fp );
+		VIPS_FREEF( fclose, file->fp );
+	}
+
+	VIPS_FOREIGN_LOAD_GIF_CLASS(
+		vips_foreign_load_gif_file_parent_class )->close( gif );
+}
+
 static const char *vips_foreign_gif_suffs[] = {
 	".gif",
 	NULL
@@ -1239,7 +1376,6 @@ vips_foreign_load_gif_file_class_init(
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
 	VipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;
 
-	gobject_class->dispose = vips_foreign_load_gif_file_dispose;
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
@@ -1251,6 +1387,8 @@ vips_foreign_load_gif_file_class_init(
 	load_class->is_a = vips_foreign_load_gif_is_a;
 
 	gif_class->open = vips_foreign_load_gif_file_open;
+	gif_class->rewind = vips_foreign_load_gif_file_rewind;
+	gif_class->close = vips_foreign_load_gif_file_close;
 
 	VIPS_ARG_STRING( class, "filename", 1, 
 		_( "Filename" ),
@@ -1264,6 +1402,7 @@ vips_foreign_load_gif_file_class_init(
 static void
 vips_foreign_load_gif_file_init( VipsForeignLoadGifFile *file )
 {
+	file->seek_position = -1;
 }
 
 typedef struct _VipsForeignLoadGifBuffer {
@@ -1311,13 +1450,33 @@ vips_foreign_load_gif_buffer_open( VipsForeignLoadGif *gif )
 {
 	VipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;
 
-	vips_foreign_load_gif_close( gif );
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_buffer_open:\n" );
+
+	/* We can open several times -- make sure we don't move the read point
+	 * if we reopen.
+	 */
+	if( !buffer->p ) {
+		buffer->p = buffer->buf->data;
+		buffer->bytes_to_go = buffer->buf->length;
+		gif->read_func = vips_giflib_buffer_read;
+	}
+
+	return( VIPS_FOREIGN_LOAD_GIF_CLASS(
+		vips_foreign_load_gif_buffer_parent_class )->open( gif ) );
+}
+
+static void
+vips_foreign_load_gif_buffer_rewind( VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;
+
+	VIPS_DEBUG_MSG( "vips_foreign_load_gif_buffer_rewind:\n" );
+
 	buffer->p = buffer->buf->data;
 	buffer->bytes_to_go = buffer->buf->length;
-	gif->read_func = vips_giflib_buffer_read;;
 
-	return( VIPS_FOREIGN_LOAD_GIF_CLASS( 
-		vips_foreign_load_gif_file_parent_class )->open( gif ) );
+	VIPS_FOREIGN_LOAD_GIF_CLASS(
+		vips_foreign_load_gif_buffer_parent_class )->rewind( gif );
 }
 
 static void
@@ -1338,6 +1497,7 @@ vips_foreign_load_gif_buffer_class_init(
 	load_class->is_a_buffer = vips_foreign_load_gif_is_a_buffer;
 
 	gif_class->open = vips_foreign_load_gif_buffer_open;
+	gif_class->rewind = vips_foreign_load_gif_buffer_rewind;
 
 	VIPS_ARG_BOXED( class, "buffer", 1, 
 		_( "Buffer" ),
diff --git a/libvips/foreign/heifload.c b/libvips/foreign/heifload.c
index 1111111..2222222 100644
--- a/libvips/foreign/heifload.c
+++ b/libvips/foreign/heifload.c
@@ -4,6 +4,11 @@
  * 	- from niftiload.c
  * 24/7/19 [zhoux2016]
  * 	- always fetch metadata from the main image (thumbs don't have it)
+ * 24/7/19
+ * 	- close early on minimise 
+ * 	- close early on error
+ * 3/10/19
+ * 	- restart after minimise
  */
 
 /*
@@ -58,6 +63,21 @@
 
 #include "pforeign.h"
 
+#define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
+#define VIPS_FOREIGN_LOAD_HEIF( obj ) \
+	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
+	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
+#define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
+	(G_TYPE_CHECK_CLASS_CAST( (klass), \
+	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
+#define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
+	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
+#define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
+	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
+#define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
+	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
+	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))
+
 typedef struct _VipsForeignLoadHeif {
 	VipsForeignLoad parent_object;
 
@@ -125,19 +145,34 @@ typedef struct _VipsForeignLoadHeif {
 
 } VipsForeignLoadHeif;
 
-typedef VipsForeignLoadClass VipsForeignLoadHeifClass;
+typedef struct _VipsForeignLoadHeifClass {
+	VipsForeignLoadClass parent_class;
+
+	/* Open the reader, eg. call heif_context_read_from_memory() etc. This
+	 * has to be a vfunc so generate can restart after minimise.
+	 */
+	int (*open)( VipsForeignLoadHeif *heif );
+
+} VipsForeignLoadHeifClass;
 
 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
 	VIPS_TYPE_FOREIGN_LOAD );
 
 static void
-vips_foreign_load_heif_dispose( GObject *gobject )
+vips_foreign_load_heif_close( VipsForeignLoadHeif *heif )
 {
-	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
-
 	VIPS_FREEF( heif_image_release, heif->img );
+	heif->data = NULL;
 	VIPS_FREEF( heif_image_handle_release, heif->handle );
 	VIPS_FREEF( heif_context_free, heif->ctx );
+}
+
+static void
+vips_foreign_load_heif_dispose( GObject *gobject )
+{
+	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
+
+	vips_foreign_load_heif_close( heif );
 	VIPS_FREE( heif->id );
 
 	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )->
@@ -446,11 +481,16 @@ vips_foreign_load_heif_header( VipsForeignLoad *load )
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
+	VipsForeignLoadHeifClass *heif_class = 
+		VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( heif );
 
 	struct heif_error error;
 	heif_item_id primary_id;
 	int i;
 
+	if( heif_class->open( heif ) )
+		return( -1 );
+
 	heif->n_top = heif_context_get_number_of_top_level_images( heif->ctx );
 	heif->id = VIPS_ARRAY( NULL, heif->n_top, heif_item_id );
 	heif_context_get_list_of_top_level_image_IDs( heif->ctx, 
@@ -580,6 +620,8 @@ vips_foreign_load_heif_header( VipsForeignLoad *load )
 	if( vips_foreign_load_heif_set_header( heif, load->out ) )
 		return( -1 );
 
+	vips_foreign_load_heif_close( heif ); 
+
 	return( 0 );
 }
 
@@ -589,6 +631,8 @@ vips_foreign_load_heif_generate( VipsRegion *or,
 {
 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
+	VipsForeignLoadHeifClass *heif_class = 
+		VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( heif );
         VipsRect *r = &or->valid;
 
 	int page = r->top / heif->page_height + heif->page;
@@ -600,6 +644,9 @@ vips_foreign_load_heif_generate( VipsRegion *or,
 
 	g_assert( r->height == 1 );
 
+	if( heif_class->open( heif ) )
+		return( -1 );
+
 	if( vips_foreign_load_heif_set_page( heif, page, heif->thumbnail ) )
 		return( -1 );
 
@@ -706,10 +753,18 @@ vips_foreign_load_heif_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
+{
+	vips_foreign_load_heif_close( heif );
+}
+
 static int
 vips_foreign_load_heif_load( VipsForeignLoad *load )
 {
 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
+	VipsForeignLoadHeifClass *class = 
+		VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( heif );
 
 	VipsImage **t = (VipsImage **) 
 		vips_object_local_array( VIPS_OBJECT( load ), 3 );
@@ -718,9 +773,18 @@ vips_foreign_load_heif_load( VipsForeignLoad *load )
 	printf( "vips_foreign_load_heif_load: loading image\n" );
 #endif /*DEBUG*/
 
+	if( class->open( heif ) )
+		return( -1 );
+
 	t[0] = vips_image_new();
 	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
 		return( -1 );
+
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
+
 	if( vips_image_generate( t[0],
 		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
 		vips_sequential( t[0], &t[1], NULL ) ||
@@ -730,12 +794,20 @@ vips_foreign_load_heif_load( VipsForeignLoad *load )
 	return( 0 );
 }
 
+static int
+vips_foreign_load_heif_open( VipsForeignLoadHeif *heif )
+{
+	return( 0 );
+}
+
 static void
 vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
 {
 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 	VipsObjectClass *object_class = (VipsObjectClass *) class;
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+	VipsForeignLoadHeifClass *heif_class = 
+		(VipsForeignLoadHeifClass *) class;
 
 	gobject_class->dispose = vips_foreign_load_heif_dispose;
 	gobject_class->set_property = vips_object_set_property;
@@ -748,6 +820,8 @@ vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
 	load_class->header = vips_foreign_load_heif_header;
 	load_class->load = vips_foreign_load_heif_load;
 
+	heif_class->open = vips_foreign_load_heif_open;
+
 	VIPS_ARG_INT( class, "page", 2,
 		_( "Page" ),
 		_( "Load this page from the file" ),
@@ -781,7 +855,6 @@ vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
 static void
 vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
 {
-	heif->ctx = heif_context_alloc();
 	heif->n = 1;
 }
 
@@ -816,17 +889,13 @@ vips_foreign_load_heif_file_header( VipsForeignLoad *load )
 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
 	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) load;
 
-	struct heif_error error;
-
-	error = heif_context_read_from_file( heif->ctx, file->filename, NULL );
-	if( error.code ) {
-		vips__heif_error( &error );
-		return( -1 );
-	}
-
 	if( VIPS_FOREIGN_LOAD_CLASS( 
-		vips_foreign_load_heif_file_parent_class )->header( load ) )
+		vips_foreign_load_heif_file_parent_class )->header( load ) ) {
+		/* Close early if our base class fails to read.
+		 */
+		vips_foreign_load_heif_close( heif ); 
 		return( -1 );
+	}
 
 	VIPS_SETSTR( load->out->filename, file->filename );
 
@@ -838,6 +907,31 @@ const char *vips__heif_suffs[] = {
 	NULL 
 };
 
+static int
+vips_foreign_load_heif_file_open( VipsForeignLoadHeif *heif )
+{
+	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) heif;
+
+	if( !heif->ctx ) {
+		struct heif_error error;
+
+		heif->ctx = heif_context_alloc();
+
+		error = heif_context_read_from_file( heif->ctx, 
+			file->filename, NULL );
+		if( error.code ) {
+			/* Make sure we close the fd as soon as we can on error.
+			 */
+			vips_foreign_load_heif_close( heif ); 
+			vips__heif_error( &error );
+			return( -1 );
+		}
+	}
+
+	return( VIPS_FOREIGN_LOAD_HEIF_CLASS(
+		vips_foreign_load_heif_file_parent_class )->open( heif ) );
+}
+
 static void
 vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
 {
@@ -845,6 +939,8 @@ vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
 	VipsObjectClass *object_class = (VipsObjectClass *) class;
 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+	VipsForeignLoadHeifClass *heif_class = 
+		(VipsForeignLoadHeifClass *) class;
 
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
@@ -856,6 +952,8 @@ vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
 	load_class->is_a = vips_foreign_load_heif_file_is_a;
 	load_class->header = vips_foreign_load_heif_file_header;
 
+	heif_class->open = vips_foreign_load_heif_file_open;
+
 	VIPS_ARG_STRING( class, "filename", 1, 
 		_( "Filename" ),
 		_( "Filename to load from" ),
@@ -891,25 +989,26 @@ vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
 }
 
 static int
-vips_foreign_load_heif_buffer_header( VipsForeignLoad *load )
+vips_foreign_load_heif_buffer_open( VipsForeignLoadHeif *heif )
 {
-	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
-	VipsForeignLoadHeifBuffer *buffer = (VipsForeignLoadHeifBuffer *) load;
+	VipsForeignLoadHeifBuffer *buffer = (VipsForeignLoadHeifBuffer *) heif;
 
-	struct heif_error error;
+	VIPS_DEBUG_MSG( "vips_foreign_load_heif_buffer_open:\n" );
 
-	error = heif_context_read_from_memory( heif->ctx, 
-		buffer->buf->data, buffer->buf->length, NULL );
-	if( error.code ) {
-		vips__heif_error( &error );
-		return( -1 );
-	}
+	if( !heif->ctx ) {
+		struct heif_error error;
 
-	if( VIPS_FOREIGN_LOAD_CLASS( 
-		vips_foreign_load_heif_buffer_parent_class )->header( load ) )
-		return( -1 );
+		heif->ctx = heif_context_alloc();
+		error = heif_context_read_from_memory( heif->ctx, 
+			buffer->buf->data, buffer->buf->length, NULL );
+		if( error.code ) {
+			vips__heif_error( &error );
+			return( -1 );
+		}
+	}
 
-	return( 0 );
+	return( VIPS_FOREIGN_LOAD_HEIF_CLASS(
+		vips_foreign_load_heif_buffer_parent_class )->open( heif ) );
 }
 
 static void
@@ -919,6 +1018,8 @@ vips_foreign_load_heif_buffer_class_init(
 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 	VipsObjectClass *object_class = (VipsObjectClass *) class;
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+	VipsForeignLoadHeifClass *heif_class = 
+		(VipsForeignLoadHeifClass *) class;
 
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
@@ -926,7 +1027,8 @@ vips_foreign_load_heif_buffer_class_init(
 	object_class->nickname = "heifload_buffer";
 
 	load_class->is_a_buffer = vips_foreign_load_heif_buffer_is_a;
-	load_class->header = vips_foreign_load_heif_buffer_header;
+
+	heif_class->open = vips_foreign_load_heif_buffer_open;
 
 	VIPS_ARG_BOXED( class, "buffer", 1, 
 		_( "Buffer" ),
diff --git a/libvips/foreign/jpeg2vips.c b/libvips/foreign/jpeg2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/jpeg2vips.c
+++ b/libvips/foreign/jpeg2vips.c
@@ -100,6 +100,10 @@
  * 	- strict round down on shrink-on-load
  * 16/8/18
  * 	- shut down the input file as soon as we can [kleisauke]
+ * 20/7/19
+ * 	- close input on minimise rather than Y read position
+ * 3/10/19
+ * 	- restart after minimise
  */
 
 /*
@@ -188,25 +192,159 @@ typedef struct _ReadJpeg {
 	 */
 	int output_width;
 	int output_height;
+
+	/* If we close and reopen, save the ftell point here.
+	 */
+	long seek_position;
+
+	/* The memory area we read from.
+	 */
+	const void *buf;
+	size_t len;
+
 } ReadJpeg;
 
-/* This can be called many times. It's called directly at the end of image
- * read.
+/* Private struct for memory input.
  */
+typedef struct {
+	/* Public jpeg fields.
+	 */
+	struct jpeg_source_mgr pub;
+
+	/* Private stuff during read.
+	 */
+	const JOCTET *buf;
+	size_t len;
+} InputBuffer;
+
 static void
-readjpeg_close_input( ReadJpeg *jpeg )
+init_source( j_decompress_ptr cinfo )
 {
-	VIPS_FREEF( fclose, jpeg->eman.fp );
+}
 
-	/* Don't call jpeg_finish_decompress(). It just checks the tail of the
-	 * file and who cares about that. All mem is freed in
-	 * jpeg_destroy_decompress().
-	 */
+/*
+ * Fill the input buffer --- called whenever buffer is emptied.
+ *
+ * We fill the buffer on readjpeg_buffer(), so this will only be called if
+ * libjpeg tries to read beyond the buffer.
+ */
+static boolean
+fill_input_buffer( j_decompress_ptr cinfo )
+{
+	static const JOCTET eoi_buffer[4] = {
+		(JOCTET) 0xFF, (JOCTET) JPEG_EOI, 0, 0
+	};
 
-	/* I don't think this can fail. It's harmless to call many times. 
-	 */
-	jpeg_destroy_decompress( &jpeg->cinfo );
+	InputBuffer *src = (InputBuffer *) cinfo->src;
 
+	WARNMS( cinfo, JWRN_JPEG_EOF );
+	src->pub.next_input_byte = eoi_buffer;
+	src->pub.bytes_in_buffer = 2;
+
+	return( TRUE );
+}
+
+/*
+ * Skip data --- used to skip over a potentially large amount of
+ * uninteresting data (such as an APPn marker).
+ *
+ * Writers of suspendable-input applications must note that skip_input_data
+ * is not granted the right to give a suspension return.  If the skip extends
+ * beyond the data currently in the buffer, the buffer can be marked empty so
+ * that the next read will cause a fill_input_buffer call that can suspend.
+ * Arranging for additional bytes to be discarded before reloading the input
+ * buffer is the application writer's problem.
+ */
+static void
+skip_input_data( j_decompress_ptr cinfo, long num_bytes )
+{
+	InputBuffer *src = (InputBuffer *) cinfo->src;
+
+	if( num_bytes > 0 ) {
+		while (num_bytes > (long) src->pub.bytes_in_buffer) {
+			num_bytes -= (long) src->pub.bytes_in_buffer;
+			(void) (*src->pub.fill_input_buffer) (cinfo);
+
+			/* note we assume that fill_input_buffer will never 
+			 * return FALSE, so suspension need not be handled.
+			 */
+		}
+
+		src->pub.next_input_byte += (size_t) num_bytes;
+		src->pub.bytes_in_buffer -= (size_t) num_bytes;
+	}
+}
+
+/*
+ * An additional method that can be provided by data source modules is the
+ * resync_to_restart method for error recovery in the presence of RST markers.
+ * For the moment, this source module just uses the default resync method
+ * provided by the JPEG library.  That method assumes that no backtracking
+ * is possible.
+ */
+
+/*
+ * Terminate source --- called by jpeg_finish_decompress
+ * after all data has been read.  Often a no-op.
+ *
+ * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
+ * application must deal with any cleanup that should happen even
+ * for error exit.
+ */
+static void
+term_source( j_decompress_ptr cinfo )
+{
+}
+
+static int
+readjpeg_open_input( ReadJpeg *jpeg )
+{
+	j_decompress_ptr cinfo = &jpeg->cinfo;
+
+	if( jpeg->filename &&
+		!jpeg->eman.fp ) { 
+		if( !(jpeg->eman.fp = 
+			vips__file_open_read( jpeg->filename, NULL, FALSE )) ) 
+			return( -1 );
+		jpeg_stdio_src( cinfo, jpeg->eman.fp );
+		if( jpeg->seek_position != -1 ) 
+			fseek( jpeg->eman.fp, jpeg->seek_position, SEEK_SET );
+	}
+
+	if( jpeg->buf &&
+		!cinfo->src ) {
+		InputBuffer *src;
+
+		cinfo->src = (struct jpeg_source_mgr *)
+			(*cinfo->mem->alloc_small)( 
+				(j_common_ptr) cinfo, JPOOL_PERMANENT,
+				sizeof( InputBuffer ) );
+
+		src = (InputBuffer *) cinfo->src;
+		src->buf = jpeg->buf;
+		src->len = jpeg->len;
+
+		src->pub.init_source = init_source;
+		src->pub.fill_input_buffer = fill_input_buffer;
+		src->pub.skip_input_data = skip_input_data;
+		src->pub.resync_to_restart = jpeg_resync_to_restart; 
+		src->pub.term_source = term_source;
+		src->pub.bytes_in_buffer = jpeg->len;
+		src->pub.next_input_byte = jpeg->buf;
+	}
+
+	return( 0 );
+}
+
+/* This can be called many times. 
+ */
+static void
+readjpeg_close_input( ReadJpeg *jpeg )
+{
+	if( jpeg->eman.fp ) {
+		jpeg->seek_position = ftell( jpeg->eman.fp );
+		VIPS_FREEF( fclose, jpeg->eman.fp );
+	}
 }
 
 /* This can be called many times.
@@ -226,6 +364,15 @@ readjpeg_free( ReadJpeg *jpeg )
 
 	readjpeg_close_input( jpeg );
 
+	/* Don't call jpeg_finish_decompress(). It just checks the tail of the
+	 * file and who cares about that. All mem is freed in
+	 * jpeg_destroy_decompress().
+	 */
+
+	/* I don't think this can fail. It's harmless to call many times. 
+	 */
+	jpeg_destroy_decompress( &jpeg->cinfo );
+
 	VIPS_FREE( jpeg->filename );
 
 	return( 0 );
@@ -237,6 +384,12 @@ readjpeg_close_cb( VipsObject *object, ReadJpeg *jpeg )
 	(void) readjpeg_free( jpeg );
 }
 
+static void
+readjpeg_minimise_cb( VipsObject *object, ReadJpeg *jpeg )
+{
+	readjpeg_close_input( jpeg );
+}
+
 static ReadJpeg *
 readjpeg_new( VipsImage *out, int shrink, gboolean fail, gboolean autorotate )
 {
@@ -254,6 +407,7 @@ readjpeg_new( VipsImage *out, int shrink, gboolean fail, gboolean autorotate )
 	jpeg->eman.fp = NULL;
 	jpeg->y_pos = 0;
 	jpeg->autorotate = autorotate;
+	jpeg->seek_position = -1;
 
 	/* This is used by the error handlers to signal invalidate on the
 	 * output image.
@@ -270,6 +424,8 @@ readjpeg_new( VipsImage *out, int shrink, gboolean fail, gboolean autorotate )
 
 	g_signal_connect( out, "close", 
 		G_CALLBACK( readjpeg_close_cb ), jpeg ); 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( readjpeg_minimise_cb ), jpeg ); 
 
 	return( jpeg );
 }
@@ -280,9 +436,8 @@ static int
 readjpeg_file( ReadJpeg *jpeg, const char *filename )
 {
 	jpeg->filename = g_strdup( filename );
-        if( !(jpeg->eman.fp = vips__file_open_read( filename, NULL, FALSE )) ) 
+	if( readjpeg_open_input( jpeg ) )
                 return( -1 );
-        jpeg_stdio_src( &jpeg->cinfo, jpeg->eman.fp );
 
 	return( 0 );
 }
@@ -290,20 +445,17 @@ readjpeg_file( ReadJpeg *jpeg, const char *filename )
 static const char *
 find_chroma_subsample( struct jpeg_decompress_struct *cinfo )
 {
-	gboolean has_subsample;
-
 	/* libjpeg only uses 4:4:4 and 4:2:0, confusingly. 
 	 *
 	 * http://poynton.ca/PDFs/Chroma_subsampling_notation.pdf
 	 */
-	has_subsample = cinfo->max_h_samp_factor > 1 ||
+	gboolean has_subsample = cinfo->max_h_samp_factor > 1 ||
 		cinfo->max_v_samp_factor > 1;
-	if( cinfo->num_components > 3 )
-		/* A cmyk image.
-		 */
-		return( has_subsample ? "4:2:0:4" : "4:4:4:4" );
-	else
-		return( has_subsample ? "4:2:0" : "4:4:4" );
+	gboolean is_cmyk = cinfo->num_components > 3;
+
+	return( is_cmyk ? 
+		(has_subsample ? "4:2:0:4" : "4:4:4:4" ) :
+		(has_subsample ? "4:2:0" : "4:4:4") );
 }
 
 static int
@@ -681,12 +833,17 @@ read_jpeg_generate( VipsRegion *or,
 		VIPS_GATE_STOP( "read_jpeg_generate: work" );
 
 #ifdef DEBUG
-		printf( "read_jpeg_generate: lonjmp() exit\n" ); 
+		printf( "read_jpeg_generate: longjmp() exit\n" ); 
 #endif /*DEBUG*/
 
 		return( -1 );
 	}
 
+	/* We may have been minimised.
+	 */
+	if( readjpeg_open_input( jpeg ) )
+                return( -1 );
+
 	/* If --fail is set, we make read fail on any warnings. This
 	 * will stop on any errors from the previous jpeg_read_scanlines().
 	 * libjpeg warnings are used for serious image corruption, like
@@ -721,7 +878,7 @@ read_jpeg_generate( VipsRegion *or,
 		jpeg->y_pos += 1; 
 	}
 
-	/* Shut down the input file as soon as we can. 
+	/* Shut down the input file.
 	 */
 	if( jpeg->y_pos >= or->im->Ysize ) 
 		readjpeg_close_input( jpeg );
@@ -903,145 +1060,6 @@ vips__jpeg_read_file( const char *filename, VipsImage *out,
 	return( 0 );
 }
 
-/* Just like the above, but we read from a memory buffer.
- */
-typedef struct {
-	/* Public jpeg fields.
-	 */
-	struct jpeg_source_mgr pub;
-
-	/* Private stuff during read.
-	 */
-	const JOCTET *buf;
-	size_t len;
-} InputBuffer;
-
-static void
-init_source (j_decompress_ptr cinfo)
-{
-  /* no work necessary here */
-}
-
-/*
- * Fill the input buffer --- called whenever buffer is emptied.
- *
- * We fill the buffer on readjpeg_buffer(), so this will only be called if
- * libjpeg tries to read beyond the buffer.
- */
-
-static boolean
-fill_input_buffer (j_decompress_ptr cinfo)
-{
-  static const JOCTET eoi_buffer[4] = {
-    (JOCTET) 0xFF, (JOCTET) JPEG_EOI, 0, 0
-  };
-
-  InputBuffer *src = (InputBuffer *) cinfo->src;
-
-  WARNMS(cinfo, JWRN_JPEG_EOF);
-  src->pub.next_input_byte = eoi_buffer;
-  src->pub.bytes_in_buffer = 2;
-
-  return TRUE;
-}
-
-/*
- * Skip data --- used to skip over a potentially large amount of
- * uninteresting data (such as an APPn marker).
- *
- * Writers of suspendable-input applications must note that skip_input_data
- * is not granted the right to give a suspension return.  If the skip extends
- * beyond the data currently in the buffer, the buffer can be marked empty so
- * that the next read will cause a fill_input_buffer call that can suspend.
- * Arranging for additional bytes to be discarded before reloading the input
- * buffer is the application writer's problem.
- */
-
-static void
-skip_input_data (j_decompress_ptr cinfo, long num_bytes)
-{
-  InputBuffer *src = (InputBuffer *) cinfo->src;
-
-  if (num_bytes > 0) {
-    while (num_bytes > (long) src->pub.bytes_in_buffer) {
-      num_bytes -= (long) src->pub.bytes_in_buffer;
-      (void) (*src->pub.fill_input_buffer) (cinfo);
-
-      /* note we assume that fill_input_buffer will never return FALSE,
-       * so suspension need not be handled.
-       */
-    }
-
-    src->pub.next_input_byte += (size_t) num_bytes;
-    src->pub.bytes_in_buffer -= (size_t) num_bytes;
-  }
-}
-
-/*
- * An additional method that can be provided by data source modules is the
- * resync_to_restart method for error recovery in the presence of RST markers.
- * For the moment, this source module just uses the default resync method
- * provided by the JPEG library.  That method assumes that no backtracking
- * is possible.
- */
-
-/*
- * Terminate source --- called by jpeg_finish_decompress
- * after all data has been read.  Often a no-op.
- *
- * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
- * application must deal with any cleanup that should happen even
- * for error exit.
- */
-
-static void
-term_source (j_decompress_ptr cinfo)
-{
-  /* no work necessary here */
-}
-
-/*
- * Prepare for input from a memory buffer. The caller needs to free the
- * buffer after decompress is done, we don't take ownership.
- */
-
-static void
-readjpeg_buffer (ReadJpeg *jpeg, const void *buf, size_t len)
-{
-  j_decompress_ptr cinfo = &jpeg->cinfo;
-  InputBuffer *src;
-
-  /* Empty buffer is a fatal error.
-   */
-  if (len == 0  || buf == NULL)
-    ERREXIT(cinfo, JERR_INPUT_EMPTY);
-
-  /* The source object and input buffer are made permanent so that a series
-   * of JPEG images can be read from the same file by calling jpeg_stdio_src
-   * only before the first one.  (If we discarded the buffer at the end of
-   * one image, we'd likely lose the start of the next one.)
-   * This makes it unsafe to use this manager and a different source
-   * manager serially with the same JPEG object.  Caveat programmer.
-   */
-  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
-    cinfo->src = (struct jpeg_source_mgr *)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
-				  sizeof(InputBuffer));
-    src = (InputBuffer *) cinfo->src;
-    src->buf = buf;
-    src->len = len;
-  }
-
-  src = (InputBuffer *) cinfo->src;
-  src->pub.init_source = init_source;
-  src->pub.fill_input_buffer = fill_input_buffer;
-  src->pub.skip_input_data = skip_input_data;
-  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
-  src->pub.term_source = term_source;
-  src->pub.bytes_in_buffer = len;
-  src->pub.next_input_byte = buf;
-}
-
 int
 vips__jpeg_read_buffer( const void *buf, size_t len, VipsImage *out, 
 	gboolean header_only, int shrink, int fail, gboolean autorotate )
@@ -1054,9 +1072,10 @@ vips__jpeg_read_buffer( const void *buf, size_t len, VipsImage *out,
 	if( setjmp( jpeg->eman.jmp ) ) 
 		return( -1 );
 
-	/* Set input to buffer.
-	 */
-	readjpeg_buffer( jpeg, buf, len );
+	jpeg->buf = buf;
+	jpeg->len = len;
+	if( readjpeg_open_input( jpeg ) )
+                return( -1 );
 
 	if( vips__jpeg_read( jpeg, out, header_only ) ) 
 		return( -1 );
diff --git a/libvips/foreign/openexr2vips.c b/libvips/foreign/openexr2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/openexr2vips.c
+++ b/libvips/foreign/openexr2vips.c
@@ -348,11 +348,6 @@ vips__openexr_generate( VipsRegion *out,
 			}
 		}
 
-	/* We can't shut down the input file early for tile read, even if we
-	 * know load is in sequential mode, since we are not inside a
-	 * vips_sequential() and requests are not guaranteed to be in order.
-	 */
-
 	return( 0 );
 }
 
diff --git a/libvips/foreign/pdfiumload.c b/libvips/foreign/pdfiumload.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfiumload.c
+++ b/libvips/foreign/pdfiumload.c
@@ -395,6 +395,15 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 	return( 0 );
 }
 
+static void
+vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
+{
+	/* In seq mode, we can shut down the input at the end of computation.
+	 */
+	if( VIPS_FOREIGN_LOAD( pdf )->access == VIPS_ACCESS_SEQUENTIAL )
+		vips_foreign_load_pdf_close( pdf ); 
+}
+
 static int
 vips_foreign_load_pdf_generate( VipsRegion *or, 
 	void *seq, void *a, void *b, gboolean *stop )
@@ -455,13 +464,6 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 		i += 1;
 	}
 
-	/* In seq mode, we can shut down the input when we render the last
-	 * row.
-	 */
-	if( top >= or->im->Ysize &&
-		load->access == VIPS_ACCESS_SEQUENTIAL )
-		vips_foreign_load_pdf_close( pdf ); 
-
 	/* PDFium writes BRGA, we must swap.
 	 *
 	 * FIXME ... this is a bit slow.
@@ -495,6 +497,11 @@ vips_foreign_load_pdf_load( VipsForeignLoad *load )
 	 */
 	t[0] = vips_image_new(); 
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
+
 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
 	if( vips_image_generate( t[0], 
 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
diff --git a/libvips/foreign/pdfload.c b/libvips/foreign/pdfload.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfload.c
+++ b/libvips/foreign/pdfload.c
@@ -10,8 +10,10 @@
  * 	- use a much larger strip size, thanks bubba
  * 8/6/18
  * 	- add background param
- * 16/8/18
- * 	- shut down the input file as soon as we can [kleisauke]
+ * 16/8/18 [kleisauke]
+ * 	- shut down the input file as soon as we can 
+ * 19/9/19
+ * 	- reopen the input if we minimised too early
  */
 
 /*
@@ -66,6 +68,21 @@
 #include <cairo.h>
 #include <poppler.h>
 
+#define VIPS_TYPE_FOREIGN_LOAD_PDF (vips_foreign_load_pdf_get_type())
+#define VIPS_FOREIGN_LOAD_PDF( obj ) \
+	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
+	VIPS_TYPE_FOREIGN_LOAD_PDF, VipsForeignLoadPdf ))
+#define VIPS_FOREIGN_LOAD_PDF_CLASS( klass ) \
+	(G_TYPE_CHECK_CLASS_CAST( (klass), \
+	VIPS_TYPE_FOREIGN_LOAD_PDF, VipsForeignLoadPdfClass))
+#define VIPS_IS_FOREIGN_LOAD_PDF( obj ) \
+	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_PDF ))
+#define VIPS_IS_FOREIGN_LOAD_PDF_CLASS( klass ) \
+	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_PDF ))
+#define VIPS_FOREIGN_LOAD_PDF_GET_CLASS( obj ) \
+	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
+	VIPS_TYPE_FOREIGN_LOAD_PDF, VipsForeignLoadPdfClass ))
+
 typedef struct _VipsForeignLoadPdf {
 	VipsForeignLoad parent_object;
 
@@ -113,24 +130,24 @@ typedef struct _VipsForeignLoadPdf {
 
 } VipsForeignLoadPdf;
 
-typedef VipsForeignLoadClass VipsForeignLoadPdfClass;
+typedef struct _VipsForeignLoadPdfClass {
+	VipsForeignLoadClass parent_class;
+
+	int (*open)( VipsForeignLoadPdf *pdf );
+
+	void (*close)( VipsForeignLoadPdf *pdf );
+} VipsForeignLoadPdfClass;
 
 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPdf, vips_foreign_load_pdf, 
 	VIPS_TYPE_FOREIGN_LOAD );
 
-static void
-vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
-{
-	VIPS_UNREF( pdf->page );
-	VIPS_UNREF( pdf->doc );
-}
-
 static void
 vips_foreign_load_pdf_dispose( GObject *gobject )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) gobject;
+	VipsForeignLoadPdf *pdf = VIPS_FOREIGN_LOAD_PDF( gobject );
+	VipsForeignLoadPdfClass *class = VIPS_FOREIGN_LOAD_PDF_GET_CLASS( pdf );
 
-	vips_foreign_load_pdf_close( pdf ); 
+	class->close( pdf ); 
 
 	G_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )->
 		dispose( gobject );
@@ -139,7 +156,7 @@ vips_foreign_load_pdf_dispose( GObject *gobject )
 static int
 vips_foreign_load_pdf_build( VipsObject *object )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
+	VipsForeignLoadPdf *pdf = VIPS_FOREIGN_LOAD_PDF( object );
 
 	if( !vips_object_argument_isset( object, "scale" ) )
 		pdf->scale = pdf->dpi / 72.0;
@@ -168,7 +185,8 @@ vips_foreign_load_pdf_get_flags( VipsForeignLoad *load )
 static int
 vips_foreign_load_pdf_get_page( VipsForeignLoadPdf *pdf, int page_no )
 {
-	if( pdf->current_page != page_no ) { 
+	if( pdf->current_page != page_no ||
+		!pdf->page ) { 
 		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
 
 		VIPS_UNREF( pdf->page );
@@ -255,7 +273,9 @@ static int
 vips_foreign_load_pdf_header( VipsForeignLoad *load )
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
+	VipsForeignLoadPdf *pdf = VIPS_FOREIGN_LOAD_PDF( load );
+	VipsForeignLoadPdfClass *pdf_class = 
+		VIPS_FOREIGN_LOAD_PDF_GET_CLASS( pdf );
 
 	int top;
 	int i;
@@ -264,6 +284,9 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 	printf( "vips_foreign_load_pdf_header: %p\n", pdf );
 #endif /*DEBUG*/
 
+	if( pdf_class->open( pdf ) )
+		return( -1 );
+
 	pdf->n_pages = poppler_document_get_n_pages( pdf->doc );
 
 	/* @n == -1 means until the end of the doc.
@@ -331,15 +354,28 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 		VIPS_AREA( pdf->background )->n )) )
 		return( -1 );
 
+	pdf_class->close( pdf ); 
+
 	return( 0 );
 }
 
+static void
+vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
+{
+	VipsForeignLoadPdfClass *class = VIPS_FOREIGN_LOAD_PDF_GET_CLASS( pdf );
+#ifdef DEBUG
+	printf( "vips_foreign_load_pdf_minimise: %p\n", pdf );
+#endif /*DEBUG*/
+
+	class->close( pdf ); 
+}
+
 static int
 vips_foreign_load_pdf_generate( VipsRegion *or, 
 	void *seq, void *a, void *b, gboolean *stop )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
-	VipsForeignLoad *load = (VipsForeignLoad *) pdf;
+	VipsForeignLoadPdf *pdf = VIPS_FOREIGN_LOAD_PDF( a );
+	VipsForeignLoadPdfClass *class = VIPS_FOREIGN_LOAD_PDF_GET_CLASS( pdf );
 	VipsRect *r = &or->valid;
 
 	int top;
@@ -352,6 +388,11 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 		r->left, r->top, r->width, r->height ); 
 	 */
 
+	/* We may have been minimised. Make sure the doc is open.
+	 */
+	if( class->open( pdf ) )
+		return( -1 );
+
 	/* Poppler won't always paint the background. 
 	 */
 	vips_region_paint_pel( or, r, pdf->ink ); 
@@ -398,13 +439,6 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 		i += 1;
 	}
 
-	/* In seq mode, we can shut down the input when we render the last
-	 * row.
-	 */
-	if( top >= or->im->Ysize &&
-		load->access == VIPS_ACCESS_SEQUENTIAL )
-		vips_foreign_load_pdf_close( pdf ); 
-
 	/* Cairo makes pre-multipled BRGA, we must byteswap and unpremultiply.
 	 */
 	for( y = 0; y < r->height; y++ ) 
@@ -418,7 +452,8 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 static int
 vips_foreign_load_pdf_load( VipsForeignLoad *load )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
+	VipsForeignLoadPdf *pdf = VIPS_FOREIGN_LOAD_PDF( load );
+	VipsForeignLoadPdfClass *class = VIPS_FOREIGN_LOAD_PDF_GET_CLASS( pdf );
 	VipsImage **t = (VipsImage **) 
 		vips_object_local_array( (VipsObject *) load, 2 );
 
@@ -426,10 +461,18 @@ vips_foreign_load_pdf_load( VipsForeignLoad *load )
 	printf( "vips_foreign_load_pdf_load: %p\n", pdf );
 #endif /*DEBUG*/
 
+	if( class->open( pdf ) )
+		return( -1 );
+
 	/* Read to this image, then cache to out, see below.
 	 */
 	t[0] = vips_image_new(); 
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
+
 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
 	if( vips_image_generate( t[0], 
 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
@@ -450,6 +493,23 @@ vips_foreign_load_pdf_load( VipsForeignLoad *load )
 	return( 0 );
 }
 
+static int
+vips_foreign_load_pdf_open( VipsForeignLoadPdf *pdf )
+{
+	return( 0 );
+}
+
+static void
+vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
+{
+#ifdef DEBUG
+	printf( "vips_foreign_load_pdf_file_close:\n" );
+#endif /*DEBUG*/
+
+	VIPS_UNREF( pdf->page );
+	VIPS_UNREF( pdf->doc );
+}
+
 static void
 vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
 {
@@ -468,8 +528,12 @@ vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
 	load_class->get_flags_filename = 
 		vips_foreign_load_pdf_get_flags_filename;
 	load_class->get_flags = vips_foreign_load_pdf_get_flags;
+	load_class->header = vips_foreign_load_pdf_header;
 	load_class->load = vips_foreign_load_pdf_load;
 
+	class->open = vips_foreign_load_pdf_open;
+	class->close = vips_foreign_load_pdf_close;
+
 	VIPS_ARG_INT( class, "page", 20,
 		_( "Page" ),
 		_( "Load this page from the file" ),
@@ -548,38 +612,55 @@ vips_foreign_load_pdf_file_dispose( GObject *gobject )
 static int
 vips_foreign_load_pdf_file_header( VipsForeignLoad *load )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
 	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) load;
 
-	char *path;
+	VIPS_SETSTR( load->out->filename, file->filename );
+
+	return( VIPS_FOREIGN_LOAD_CLASS(
+		vips_foreign_load_pdf_file_parent_class )->header( load ) );
+}
+
+static const char *vips_foreign_pdf_suffs[] = {
+	".pdf",
+	NULL
+};
+
+static int
+vips_foreign_load_pdf_file_open( VipsForeignLoadPdf *pdf )
+{
+	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) pdf;
+
 	GError *error = NULL;
 
-	/* We need an absolute path for a URI.
-	 */
-	path = vips_realpath( file->filename );
-	if( !(file->uri = g_filename_to_uri( path, NULL, &error )) ) { 
+#ifdef DEBUG
+	printf( "vips_foreign_load_pdf_file_open: %s\n", file->filename );
+#endif /*DEBUG*/
+
+	if( !file->uri ) { 
+		char *path;
+
+		/* We need an absolute path for a URI.
+		 */
+		path = vips_realpath( file->filename );
+		if( !(file->uri = g_filename_to_uri( path, NULL, &error )) ) { 
+			g_free( path );
+			vips_g_error( &error );
+			return( -1 ); 
+		}
 		g_free( path );
-		vips_g_error( &error );
-		return( -1 ); 
 	}
-	g_free( path );
 
-	if( !(pdf->doc = poppler_document_new_from_file( 
-		file->uri, NULL, &error )) ) { 
+	if( !pdf->doc &&
+		!(pdf->doc = poppler_document_new_from_file( 
+			file->uri, NULL, &error )) ) { 
 		vips_g_error( &error );
 		return( -1 ); 
 	}
 
-	VIPS_SETSTR( load->out->filename, file->filename );
-
-	return( vips_foreign_load_pdf_header( load ) );
+	return( VIPS_FOREIGN_LOAD_PDF_CLASS(
+		vips_foreign_load_pdf_file_parent_class )->open( pdf ) );
 }
 
-static const char *vips_foreign_pdf_suffs[] = {
-	".pdf",
-	NULL
-};
-
 static void
 vips_foreign_load_pdf_file_class_init( 
 	VipsForeignLoadPdfFileClass *class )
@@ -600,6 +681,8 @@ vips_foreign_load_pdf_file_class_init(
 	load_class->is_a = vips_foreign_load_pdf_is_a;
 	load_class->header = vips_foreign_load_pdf_file_header;
 
+	class->open = vips_foreign_load_pdf_file_open;
+
 	VIPS_ARG_STRING( class, "filename", 1, 
 		_( "Filename" ),
 		_( "Filename to load from" ),
@@ -629,21 +712,21 @@ G_DEFINE_TYPE( VipsForeignLoadPdfBuffer, vips_foreign_load_pdf_buffer,
 	vips_foreign_load_pdf_get_type() );
 
 static int
-vips_foreign_load_pdf_buffer_header( VipsForeignLoad *load )
+vips_foreign_load_pdf_buffer_open( VipsForeignLoadPdf *pdf )
 {
-	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
-	VipsForeignLoadPdfBuffer *buffer = 
-		(VipsForeignLoadPdfBuffer *) load;
+	VipsForeignLoadPdfBuffer *buffer = (VipsForeignLoadPdfBuffer *) pdf;
 
 	GError *error = NULL;
 
-	if( !(pdf->doc = poppler_document_new_from_data( 
+	if( !pdf->doc &&
+		!(pdf->doc = poppler_document_new_from_data( 
 		buffer->buf->data, buffer->buf->length, NULL, &error )) ) { 
 		vips_g_error( &error );
 		return( -1 ); 
 	}
 
-	return( vips_foreign_load_pdf_header( load ) );
+	return( VIPS_FOREIGN_LOAD_PDF_CLASS(
+		vips_foreign_load_pdf_buffer_parent_class )->open( pdf ) );
 }
 
 static void
@@ -660,7 +743,8 @@ vips_foreign_load_pdf_buffer_class_init(
 	object_class->nickname = "pdfload_buffer";
 
 	load_class->is_a_buffer = vips_foreign_load_pdf_is_a_buffer;
-	load_class->header = vips_foreign_load_pdf_buffer_header;
+
+	class->open = vips_foreign_load_pdf_buffer_open;
 
 	VIPS_ARG_BOXED( class, "buffer", 1, 
 		_( "Buffer" ),
diff --git a/libvips/foreign/radiance.c b/libvips/foreign/radiance.c
index 1111111..2222222 100644
--- a/libvips/foreign/radiance.c
+++ b/libvips/foreign/radiance.c
@@ -987,9 +987,9 @@ vips__rad_israd( const char *filename )
 static void
 read_destroy( VipsObject *object, Read *read )
 {
-	VIPS_FREE( read->filename );
-	VIPS_FREEF( fclose, read->fin );
 	VIPS_FREEF( buffer_free, read->buffer );
+	VIPS_FREEF( fclose, read->fin );
+	VIPS_FREE( read->filename );
 }
 
 static Read *
diff --git a/libvips/foreign/tiff2vips.c b/libvips/foreign/tiff2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/tiff2vips.c
+++ b/libvips/foreign/tiff2vips.c
@@ -520,6 +520,11 @@ rtiff_new( VipsImage *out, int page, int n, gboolean autorotate )
 	g_signal_connect( out, "close", 
 		G_CALLBACK( rtiff_close_cb ), rtiff ); 
 
+	/* Don't link to minimise. We need to be able to disconnect the
+	 * underlying fd and we can't do that without making our own input
+	 * handler for files. Implement this when we add input objects.
+	 */
+
 	if( rtiff->page < 0 || rtiff->page > 1000000 ) {
 		vips_error( "tiff2vips", _( "bad page number %d" ),
 			rtiff->page );
@@ -1603,11 +1608,6 @@ rtiff_fill_region( VipsRegion *out,
 
 	VIPS_GATE_STOP( "rtiff_fill_region: work" ); 
 
-	/* We can't shut down the input file early for tile read, even if we
-	 * know load is in sequential mode, since we are not inside a
-	 * vips_sequential() and requests are not guaranteed to be in order.
-	 */
-
 	return( 0 );
 }
 
@@ -1949,11 +1949,11 @@ rtiff_stripwise_generate( VipsRegion *or,
 		rtiff->y_pos += hit.height;
 	}
 
-	/* Shut down the input file as soon as we can. 
+	/* Shut down the input file as soon as we can.
 	 */
 	if( rtiff->y_pos >= or->im->Ysize ) {
 #ifdef DEBUG
-		printf( "rtiff_stripwise_generate: early shutdown\n" ); 
+		printf( "rtiff_stripwise_generate: early shutdown\n" );
 #endif /*DEBUG*/
 		rtiff_free( rtiff );
 	}
diff --git a/libvips/foreign/vipspng.c b/libvips/foreign/vipspng.c
index 1111111..2222222 100644
--- a/libvips/foreign/vipspng.c
+++ b/libvips/foreign/vipspng.c
@@ -72,7 +72,9 @@
  * 25/8/18
  * 	- support xmp read/write
  * 20/4/19
- * 	- allow huge metadata
+ * 	- allow huge xmp metadata
+ * 7/10/19
+ * 	- restart after minimise
  */
 
 /*
@@ -167,9 +169,11 @@ typedef struct {
 	png_infop pInfo;
 	png_bytep *row_pointer;
 
-	/* For FILE input.
+	/* For FILE input. If we close and reopen, save the ftell point in
+	 * seek_position.
 	 */
 	FILE *fp;
+	long seek_position;
 
 	/* For memory input.
 	 */
@@ -179,12 +183,46 @@ typedef struct {
 
 } Read;
 
+/* This can be called many times. 
+ */
+static void
+read_close_input( Read *read )
+{
+#ifdef DEBUG
+	printf( "read_close_input:\n" );
+#endif /*DEBUG*/
+
+	if( read->fp ) {
+		read->seek_position = ftell( read->fp );
+		VIPS_FREEF( fclose, read->fp );
+	}
+}
+
+static int
+read_open_input( Read *read )
+{
+	if( !read->fp &&
+		read->name ) {
+		if( !(read->fp = 
+			vips__file_open_read( read->name, NULL, FALSE )) ) 
+			return( -1 );
+		if( read->seek_position != -1 ) 
+			fseek( read->fp, read->seek_position, SEEK_SET );
+
+		/* Just takes a copy of the fp.
+		 */
+		png_init_io( read->pPng, read->fp );
+	}
+
+	return( 0 );
+}
+
 /* Can be called many times.
  */
 static void
 read_destroy( Read *read )
 {
-	VIPS_FREEF( fclose, read->fp );
+	read_close_input( read );
 	if( read->pPng )
 		png_destroy_read_struct( &read->pPng, &read->pInfo, NULL );
 	VIPS_FREE( read->row_pointer );
@@ -196,6 +234,12 @@ read_close_cb( VipsImage *out, Read *read )
 	read_destroy( read ); 
 }
 
+static void
+read_minimise_cb( VipsImage *out, Read *read )
+{
+	read_close_input( read );
+}
+
 static Read *
 read_new( VipsImage *out, gboolean fail )
 {
@@ -212,12 +256,15 @@ read_new( VipsImage *out, gboolean fail )
 	read->pInfo = NULL;
 	read->row_pointer = NULL;
 	read->fp = NULL;
+	read->seek_position = -1;
 	read->buffer = NULL;
 	read->length = 0;
 	read->read_pos = 0;
 
 	g_signal_connect( out, "close", 
 		G_CALLBACK( read_close_cb ), read ); 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( read_minimise_cb ), read ); 
 
 	if( !(read->pPng = png_create_read_struct( 
 		PNG_LIBPNG_VER_STRING, NULL,
@@ -242,6 +289,18 @@ read_new( VipsImage *out, gboolean fail )
 	return( read );
 }
 
+static void
+read_info( Read *read ) 
+{
+	/* By default, libpng refuses to open files with a metadata chunk 
+	 * larger than 8mb. We've seen real files with 20mb, so set 50mb.
+	 */
+#ifdef HAVE_PNG_SET_CHUNK_MALLOC_MAX
+	png_set_chunk_malloc_max( read->pPng, 50 * 1024 * 1024 );
+#endif /*HAVE_PNG_SET_CHUNK_MALLOC_MAX*/
+	png_read_info( read->pPng, read->pInfo );
+}
+
 static Read *
 read_new_filename( VipsImage *out, const char *name, gboolean fail )
 {
@@ -252,25 +311,17 @@ read_new_filename( VipsImage *out, const char *name, gboolean fail )
 
 	read->name = vips_strdup( VIPS_OBJECT( out ), name );
 
-        if( !(read->fp = vips__file_open_read( name, NULL, FALSE )) ) 
+	if( read_open_input( read ) )
 		return( NULL );
 
 	/* Catch PNG errors from png_read_info().
 	 */
-	if( setjmp( png_jmpbuf( read->pPng ) ) ) 
+	if( setjmp( png_jmpbuf( read->pPng ) ) ) {
+		read_destroy( read );
 		return( NULL );
+	}
 
-	/* Read enough of the file that png_get_interlace_type() will start
-	 * working.
-	 *
-	 * By default, libpng refuses to open files with a metadata chunk 
-	 * larger than 8mb. We've seen real files with 20mb, so set 50mb.
-	 */
-	png_init_io( read->pPng, read->fp );
-#ifdef HAVE_PNG_SET_CHUNK_MALLOC_MAX
-	png_set_chunk_malloc_max( read->pPng, 50 * 1024 * 1024 );
-#endif /*HAVE_PNG_SET_CHUNK_MALLOC_MAX*/
-	png_read_info( read->pPng, read->pInfo );
+	read_info( read ); 
 
 	return( read );
 }
@@ -522,13 +573,13 @@ vips__png_header( const char *name, VipsImage *out )
 {
 	Read *read;
 
-	if( !(read = read_new_filename( out, name, TRUE )) ||
-		png2vips_header( read, out ) ) 
+	if( !(read = read_new_filename( out, name, TRUE )) )
 		return( -1 );
-
-	/* Just a header read: we can free the read early and save an fd.
-	 */
-	read_destroy( read );
+	if( png2vips_header( read, out ) ) {
+		read_close_input( read );
+		return( -1 );
+	}
+	read_close_input( read );
 
 	return( 0 );
 }
@@ -591,6 +642,9 @@ png2vips_generate( VipsRegion *or,
 	g_assert( r->height == VIPS_MIN( VIPS__FATSTRIP_HEIGHT, 
 			or->im->Ysize - r->top ) ); 
 
+	if( read_open_input( read ) )
+		return( -1 );
+
 	/* And check that y_pos is correct. It should be, since we are inside
 	 * a vips_sequential().
 	 */
@@ -636,22 +690,21 @@ png2vips_generate( VipsRegion *or,
 	}
 
 	/* Catch errors from png_read_end(). This can fail on a truncated
-	 * file. 
+	 * file.
 	 */
 	if( setjmp( png_jmpbuf( read->pPng ) ) ) {
 		if( read->fail ) {
-			vips_error( "vipspng", "%s", _( "libpng read error" ) ); 
+			vips_error( "vipspng", "%s", _( "libpng read error" ) );
 			return( -1 );
 		}
 
 		return( 0 );
 	}
 
-	/* We need to shut down the reader immediately at the end of read or
-	 * we won't detach ready for the next image.
+	/* Early close to free the fd as soon as we can.
 	 */
 	if( read->y_pos >= read->out->Ysize ) {
-		png_read_end( read->pPng, NULL ); 
+		png_read_end( read->pPng, NULL );
 		read_destroy( read );
 	}
 
@@ -709,6 +762,10 @@ png2vips_image( Read *read, VipsImage *out )
 			return( -1 );
 	}
 
+	/* _generate will reopen.
+	 */
+	read_close_input( read );
+
 	return( 0 );
 }
 
@@ -783,13 +840,12 @@ read_new_buffer( VipsImage *out, const void *buffer, size_t length,
 
 	/* Catch PNG errors from png_read_info().
 	 */
-	if( setjmp( png_jmpbuf( read->pPng ) ) ) 
+	if( setjmp( png_jmpbuf( read->pPng ) ) ) {
+		read_destroy( read );
 		return( NULL );
+	}
 
-	/* Read enough of the file that png_get_interlace_type() will start
-	 * working.
-	 */
-	png_read_info( read->pPng, read->pInfo );
+	read_info( read ); 
 
 	return( read );
 }
diff --git a/libvips/foreign/webp2vips.c b/libvips/foreign/webp2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/webp2vips.c
+++ b/libvips/foreign/webp2vips.c
@@ -338,8 +338,8 @@ vips__iswebp( const char *filename )
 	return( 0 );
 }
 
-static int
-read_free( Read *read )
+static void
+read_minimise( Read *read )
 {
 	WebPDemuxReleaseIterator( &read->iter );
 	VIPS_UNREF( read->frame );
@@ -355,6 +355,13 @@ read_free( Read *read )
 	}
 
 	VIPS_FREEF( vips_tracked_close, read->fd ); 
+}
+
+static int
+read_free( Read *read )
+{
+	read_minimise( read );
+
 	VIPS_FREE( read->filename );
 	VIPS_FREE( read );
 
@@ -751,6 +758,12 @@ read_webp_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+read_minimise_cb( VipsObject *object, Read *read )
+{
+	read_minimise( read );
+}
+
 static int
 read_image( Read *read, VipsImage *out )
 {
@@ -761,6 +774,9 @@ read_image( Read *read, VipsImage *out )
 	if( read_header( read, t[0] ) )
 		return( -1 );
 
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( read_minimise_cb ), read );
+
 	if( vips_image_generate( t[0], 
 		NULL, read_webp_generate, NULL, read, NULL ) ||
 		vips_sequential( t[0], &t[1], NULL ) ||
diff --git a/libvips/resample/shrinkv.c b/libvips/resample/shrinkv.c
index 1111111..2222222 100644
--- a/libvips/resample/shrinkv.c
+++ b/libvips/resample/shrinkv.c
@@ -45,8 +45,6 @@
  * 	- rename yshrink -> vshrink for greater consistency 
  * 7/3/17
  * 	- add a seq line cache
- * 9/7/19
- * 	- read the tail of the input to force early shutdown in seq readers
  */
 
 /*
@@ -101,7 +99,6 @@ typedef struct _VipsShrinkv {
 
 	int vshrink;
 	size_t sizeof_line_buffer;
-	gboolean sequential;
 
 } VipsShrinkv;
 
@@ -268,7 +265,6 @@ vips_shrinkv_gen( VipsRegion *or, void *vseq,
 {
 	VipsShrinkvSequence *seq = (VipsShrinkvSequence *) vseq;
 	VipsShrinkv *shrink = (VipsShrinkv *) b;
-	VipsResample *resample = VIPS_RESAMPLE( shrink );
 	VipsRegion *ir = seq->ir;
 	VipsRect *r = &or->valid;
 
@@ -319,38 +315,6 @@ vips_shrinkv_gen( VipsRegion *or, void *vseq,
 
 	VIPS_COUNT_PIXELS( or, "vips_shrinkv_gen" ); 
 
-	/* If we are in seq mode and we've just generated the last line of 
-	 * the output, make sure we read all of the input.
-	 *
-	 * This will trigger the early shutdown logic in things like the 
-	 * tiff loader.
-	 */
-	if( shrink->sequential &&
-		r->top + r->height >= or->im->Ysize ) {
-		/* First unused scanline. resample->in->Ysize because we want
-		 * the height before the embed.
-		 *
-		 * Because we round to nearest, unused can be negative.
-		 */
-		int first = or->im->Ysize * shrink->vshrink;
-		int unused = resample->in->Ysize - first;
-
-		for( y = 0; y < unused; y++ ) { 
-			VipsRect s;
-
-			s.left = r->left;
-			s.top = first + y;
-			s.width = r->width;
-			s.height = 1;
-#ifdef DEBUG
-			printf( "shrink_gen: requesting tail %d\n", s.top ); 
-#endif /*DEBUG*/
-
-			if( vips_region_prepare( ir, &s ) )
-				return( -1 );
-		}
-	}
-
 	return( 0 );
 }
 
@@ -451,8 +415,6 @@ vips_shrinkv_build( VipsObject *object )
 	if( vips_image_get_typeof( in, VIPS_META_SEQUENTIAL ) ) { 
 		g_info( "shrinkv sequential line cache" ); 
 
-		shrink->sequential = TRUE;
-
 		if( vips_sequential( in, &t[3], 
 			"tile_height", 10,
 			NULL ) )
